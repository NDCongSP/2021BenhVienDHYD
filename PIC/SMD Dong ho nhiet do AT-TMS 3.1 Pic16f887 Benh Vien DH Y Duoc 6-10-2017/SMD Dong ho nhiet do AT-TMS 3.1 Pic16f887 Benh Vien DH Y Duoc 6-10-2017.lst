CCS PCM C Compiler, Version 5.109, 43599               05-Jan-23 14:56

               Filename:   D:\MyCompany\8.SourceCode\3.Projects\2021BenhVienDHYD\PIC\SMD Dong ho nhiet do AT-TMS 3.1 Pic16f887 Benh Vien DH Y Duoc 6-10-2017\SMD Dong ho nhiet do AT-TMS 3.1 Pic16f887 Benh Vien DH Y Duoc 6-10-2017.lst

               ROM used:   7967 words (97%)
                           Largest free fragment is 121
               RAM used:   191 (52%) at main() level
                           216 (59%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  1C
0001:  MOVWF  0A
0002:  GOTO   489
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   034
001D:  MOVLW  8C
001E:  MOVWF  04
001F:  BTFSS  00.1
0020:  GOTO   023
0021:  BTFSC  0C.1
0022:  GOTO   037
0023:  MOVF   22,W
0024:  MOVWF  04
0025:  MOVF   23,W
0026:  MOVWF  77
0027:  MOVF   24,W
0028:  MOVWF  78
0029:  MOVF   25,W
002A:  MOVWF  79
002B:  MOVF   26,W
002C:  MOVWF  7A
002D:  MOVF   20,W
002E:  MOVWF  0A
002F:  SWAPF  21,W
0030:  MOVWF  03
0031:  SWAPF  7F,F
0032:  SWAPF  7F,W
0033:  RETFIE
0034:  BCF    0A.3
0035:  BCF    0A.4
0036:  GOTO   2B1
0037:  BCF    0A.3
0038:  BCF    0A.4
0039:  GOTO   275
.................... #include <16f887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
003A:  BCF    0A.0
003B:  BCF    0A.1
003C:  BCF    0A.2
003D:  ADDLW  41
003E:  BTFSC  03.0
003F:  INCF   0A,F
0040:  MOVWF  02
0041:  RETLW  00
0042:  RETLW  C1
0043:  RETLW  81
0044:  RETLW  40
0045:  RETLW  01
0046:  RETLW  C0
0047:  RETLW  80
0048:  RETLW  41
0049:  RETLW  01
004A:  RETLW  C0
004B:  RETLW  80
004C:  RETLW  41
004D:  RETLW  00
004E:  RETLW  C1
004F:  RETLW  81
0050:  RETLW  40
0051:  RETLW  01
0052:  RETLW  C0
0053:  RETLW  80
0054:  RETLW  41
0055:  RETLW  00
0056:  RETLW  C1
0057:  RETLW  81
0058:  RETLW  40
0059:  RETLW  00
005A:  RETLW  C1
005B:  RETLW  81
005C:  RETLW  40
005D:  RETLW  01
005E:  RETLW  C0
005F:  RETLW  80
0060:  RETLW  41
0061:  RETLW  01
0062:  RETLW  C0
0063:  RETLW  80
0064:  RETLW  41
0065:  RETLW  00
0066:  RETLW  C1
0067:  RETLW  81
0068:  RETLW  40
0069:  RETLW  00
006A:  RETLW  C1
006B:  RETLW  81
006C:  RETLW  40
006D:  RETLW  01
006E:  RETLW  C0
006F:  RETLW  80
0070:  RETLW  41
0071:  RETLW  00
0072:  RETLW  C1
0073:  RETLW  81
0074:  RETLW  40
0075:  RETLW  01
0076:  RETLW  C0
0077:  RETLW  80
0078:  RETLW  41
0079:  RETLW  01
007A:  RETLW  C0
007B:  RETLW  80
007C:  RETLW  41
007D:  RETLW  00
007E:  RETLW  C1
007F:  RETLW  81
0080:  RETLW  40
0081:  RETLW  01
0082:  RETLW  C0
0083:  RETLW  80
0084:  RETLW  41
0085:  RETLW  00
0086:  RETLW  C1
0087:  RETLW  81
0088:  RETLW  40
0089:  RETLW  00
008A:  RETLW  C1
008B:  RETLW  81
008C:  RETLW  40
008D:  RETLW  01
008E:  RETLW  C0
008F:  RETLW  80
0090:  RETLW  41
0091:  RETLW  00
0092:  RETLW  C1
0093:  RETLW  81
0094:  RETLW  40
0095:  RETLW  01
0096:  RETLW  C0
0097:  RETLW  80
0098:  RETLW  41
0099:  RETLW  01
009A:  RETLW  C0
009B:  RETLW  80
009C:  RETLW  41
009D:  RETLW  00
009E:  RETLW  C1
009F:  RETLW  81
00A0:  RETLW  40
00A1:  RETLW  00
00A2:  RETLW  C1
00A3:  RETLW  81
00A4:  RETLW  40
00A5:  RETLW  01
00A6:  RETLW  C0
00A7:  RETLW  80
00A8:  RETLW  41
00A9:  RETLW  01
00AA:  RETLW  C0
00AB:  RETLW  80
00AC:  RETLW  41
00AD:  RETLW  00
00AE:  RETLW  C1
00AF:  RETLW  81
00B0:  RETLW  40
00B1:  RETLW  01
00B2:  RETLW  C0
00B3:  RETLW  80
00B4:  RETLW  41
00B5:  RETLW  00
00B6:  RETLW  C1
00B7:  RETLW  81
00B8:  RETLW  40
00B9:  RETLW  00
00BA:  RETLW  C1
00BB:  RETLW  81
00BC:  RETLW  40
00BD:  RETLW  01
00BE:  RETLW  C0
00BF:  RETLW  80
00C0:  RETLW  41
00C1:  RETLW  01
00C2:  RETLW  C0
00C3:  RETLW  80
00C4:  RETLW  41
00C5:  RETLW  00
00C6:  RETLW  C1
00C7:  RETLW  81
00C8:  RETLW  40
00C9:  RETLW  00
00CA:  RETLW  C1
00CB:  RETLW  81
00CC:  RETLW  40
00CD:  RETLW  01
00CE:  RETLW  C0
00CF:  RETLW  80
00D0:  RETLW  41
00D1:  RETLW  00
00D2:  RETLW  C1
00D3:  RETLW  81
00D4:  RETLW  40
00D5:  RETLW  01
00D6:  RETLW  C0
00D7:  RETLW  80
00D8:  RETLW  41
00D9:  RETLW  01
00DA:  RETLW  C0
00DB:  RETLW  80
00DC:  RETLW  41
00DD:  RETLW  00
00DE:  RETLW  C1
00DF:  RETLW  81
00E0:  RETLW  40
00E1:  RETLW  00
00E2:  RETLW  C1
00E3:  RETLW  81
00E4:  RETLW  40
00E5:  RETLW  01
00E6:  RETLW  C0
00E7:  RETLW  80
00E8:  RETLW  41
00E9:  RETLW  01
00EA:  RETLW  C0
00EB:  RETLW  80
00EC:  RETLW  41
00ED:  RETLW  00
00EE:  RETLW  C1
00EF:  RETLW  81
00F0:  RETLW  40
00F1:  RETLW  01
00F2:  RETLW  C0
00F3:  RETLW  80
00F4:  RETLW  41
00F5:  RETLW  00
00F6:  RETLW  C1
00F7:  RETLW  81
00F8:  RETLW  40
00F9:  RETLW  00
00FA:  RETLW  C1
00FB:  RETLW  81
00FC:  RETLW  40
00FD:  RETLW  01
00FE:  RETLW  C0
00FF:  RETLW  80
0100:  RETLW  41
0101:  RETLW  00
0102:  RETLW  C1
0103:  RETLW  81
0104:  RETLW  40
0105:  RETLW  01
0106:  RETLW  C0
0107:  RETLW  80
0108:  RETLW  41
0109:  RETLW  01
010A:  RETLW  C0
010B:  RETLW  80
010C:  RETLW  41
010D:  RETLW  00
010E:  RETLW  C1
010F:  RETLW  81
0110:  RETLW  40
0111:  RETLW  01
0112:  RETLW  C0
0113:  RETLW  80
0114:  RETLW  41
0115:  RETLW  00
0116:  RETLW  C1
0117:  RETLW  81
0118:  RETLW  40
0119:  RETLW  00
011A:  RETLW  C1
011B:  RETLW  81
011C:  RETLW  40
011D:  RETLW  01
011E:  RETLW  C0
011F:  RETLW  80
0120:  RETLW  41
0121:  RETLW  01
0122:  RETLW  C0
0123:  RETLW  80
0124:  RETLW  41
0125:  RETLW  00
0126:  RETLW  C1
0127:  RETLW  81
0128:  RETLW  40
0129:  RETLW  00
012A:  RETLW  C1
012B:  RETLW  81
012C:  RETLW  40
012D:  RETLW  01
012E:  RETLW  C0
012F:  RETLW  80
0130:  RETLW  41
0131:  RETLW  00
0132:  RETLW  C1
0133:  RETLW  81
0134:  RETLW  40
0135:  RETLW  01
0136:  RETLW  C0
0137:  RETLW  80
0138:  RETLW  41
0139:  RETLW  01
013A:  RETLW  C0
013B:  RETLW  80
013C:  RETLW  41
013D:  RETLW  00
013E:  RETLW  C1
013F:  RETLW  81
0140:  RETLW  40
0141:  BSF    0A.0
0142:  BCF    0A.1
0143:  BCF    0A.2
0144:  ADDLW  48
0145:  BTFSC  03.0
0146:  INCF   0A,F
0147:  MOVWF  02
0148:  RETLW  00
0149:  RETLW  C0
014A:  RETLW  C1
014B:  RETLW  01
014C:  RETLW  C3
014D:  RETLW  03
014E:  RETLW  02
014F:  RETLW  C2
0150:  RETLW  C6
0151:  RETLW  06
0152:  RETLW  07
0153:  RETLW  C7
0154:  RETLW  05
0155:  RETLW  C5
0156:  RETLW  C4
0157:  RETLW  04
0158:  RETLW  CC
0159:  RETLW  0C
015A:  RETLW  0D
015B:  RETLW  CD
015C:  RETLW  0F
015D:  RETLW  CF
015E:  RETLW  CE
015F:  RETLW  0E
0160:  RETLW  0A
0161:  RETLW  CA
0162:  RETLW  CB
0163:  RETLW  0B
0164:  RETLW  C9
0165:  RETLW  09
0166:  RETLW  08
0167:  RETLW  C8
0168:  RETLW  D8
0169:  RETLW  18
016A:  RETLW  19
016B:  RETLW  D9
016C:  RETLW  1B
016D:  RETLW  DB
016E:  RETLW  DA
016F:  RETLW  1A
0170:  RETLW  1E
0171:  RETLW  DE
0172:  RETLW  DF
0173:  RETLW  1F
0174:  RETLW  DD
0175:  RETLW  1D
0176:  RETLW  1C
0177:  RETLW  DC
0178:  RETLW  14
0179:  RETLW  D4
017A:  RETLW  D5
017B:  RETLW  15
017C:  RETLW  D7
017D:  RETLW  17
017E:  RETLW  16
017F:  RETLW  D6
0180:  RETLW  D2
0181:  RETLW  12
0182:  RETLW  13
0183:  RETLW  D3
0184:  RETLW  11
0185:  RETLW  D1
0186:  RETLW  D0
0187:  RETLW  10
0188:  RETLW  F0
0189:  RETLW  30
018A:  RETLW  31
018B:  RETLW  F1
018C:  RETLW  33
018D:  RETLW  F3
018E:  RETLW  F2
018F:  RETLW  32
0190:  RETLW  36
0191:  RETLW  F6
0192:  RETLW  F7
0193:  RETLW  37
0194:  RETLW  F5
0195:  RETLW  35
0196:  RETLW  34
0197:  RETLW  F4
0198:  RETLW  3C
0199:  RETLW  FC
019A:  RETLW  FD
019B:  RETLW  3D
019C:  RETLW  FF
019D:  RETLW  3F
019E:  RETLW  3E
019F:  RETLW  FE
01A0:  RETLW  FA
01A1:  RETLW  3A
01A2:  RETLW  3B
01A3:  RETLW  FB
01A4:  RETLW  39
01A5:  RETLW  F9
01A6:  RETLW  F8
01A7:  RETLW  38
01A8:  RETLW  28
01A9:  RETLW  E8
01AA:  RETLW  E9
01AB:  RETLW  29
01AC:  RETLW  EB
01AD:  RETLW  2B
01AE:  RETLW  2A
01AF:  RETLW  EA
01B0:  RETLW  EE
01B1:  RETLW  2E
01B2:  RETLW  2F
01B3:  RETLW  EF
01B4:  RETLW  2D
01B5:  RETLW  ED
01B6:  RETLW  EC
01B7:  RETLW  2C
01B8:  RETLW  E4
01B9:  RETLW  24
01BA:  RETLW  25
01BB:  RETLW  E5
01BC:  RETLW  27
01BD:  RETLW  E7
01BE:  RETLW  E6
01BF:  RETLW  26
01C0:  RETLW  22
01C1:  RETLW  E2
01C2:  RETLW  E3
01C3:  RETLW  23
01C4:  RETLW  E1
01C5:  RETLW  21
01C6:  RETLW  20
01C7:  RETLW  E0
01C8:  RETLW  A0
01C9:  RETLW  60
01CA:  RETLW  61
01CB:  RETLW  A1
01CC:  RETLW  63
01CD:  RETLW  A3
01CE:  RETLW  A2
01CF:  RETLW  62
01D0:  RETLW  66
01D1:  RETLW  A6
01D2:  RETLW  A7
01D3:  RETLW  67
01D4:  RETLW  A5
01D5:  RETLW  65
01D6:  RETLW  64
01D7:  RETLW  A4
01D8:  RETLW  6C
01D9:  RETLW  AC
01DA:  RETLW  AD
01DB:  RETLW  6D
01DC:  RETLW  AF
01DD:  RETLW  6F
01DE:  RETLW  6E
01DF:  RETLW  AE
01E0:  RETLW  AA
01E1:  RETLW  6A
01E2:  RETLW  6B
01E3:  RETLW  AB
01E4:  RETLW  69
01E5:  RETLW  A9
01E6:  RETLW  A8
01E7:  RETLW  68
01E8:  RETLW  78
01E9:  RETLW  B8
01EA:  RETLW  B9
01EB:  RETLW  79
01EC:  RETLW  BB
01ED:  RETLW  7B
01EE:  RETLW  7A
01EF:  RETLW  BA
01F0:  RETLW  BE
01F1:  RETLW  7E
01F2:  RETLW  7F
01F3:  RETLW  BF
01F4:  RETLW  7D
01F5:  RETLW  BD
01F6:  RETLW  BC
01F7:  RETLW  7C
01F8:  RETLW  B4
01F9:  RETLW  74
01FA:  RETLW  75
01FB:  RETLW  B5
01FC:  RETLW  77
01FD:  RETLW  B7
01FE:  RETLW  B6
01FF:  RETLW  76
0200:  RETLW  72
0201:  RETLW  B2
0202:  RETLW  B3
0203:  RETLW  73
0204:  RETLW  B1
0205:  RETLW  71
0206:  RETLW  70
0207:  RETLW  B0
0208:  RETLW  50
0209:  RETLW  90
020A:  RETLW  91
020B:  RETLW  51
020C:  RETLW  93
020D:  RETLW  53
020E:  RETLW  52
020F:  RETLW  92
0210:  RETLW  96
0211:  RETLW  56
0212:  RETLW  57
0213:  RETLW  97
0214:  RETLW  55
0215:  RETLW  95
0216:  RETLW  94
0217:  RETLW  54
0218:  RETLW  9C
0219:  RETLW  5C
021A:  RETLW  5D
021B:  RETLW  9D
021C:  RETLW  5F
021D:  RETLW  9F
021E:  RETLW  9E
021F:  RETLW  5E
0220:  RETLW  5A
0221:  RETLW  9A
0222:  RETLW  9B
0223:  RETLW  5B
0224:  RETLW  99
0225:  RETLW  59
0226:  RETLW  58
0227:  RETLW  98
0228:  RETLW  88
0229:  RETLW  48
022A:  RETLW  49
022B:  RETLW  89
022C:  RETLW  4B
022D:  RETLW  8B
022E:  RETLW  8A
022F:  RETLW  4A
0230:  RETLW  4E
0231:  RETLW  8E
0232:  RETLW  8F
0233:  RETLW  4F
0234:  RETLW  8D
0235:  RETLW  4D
0236:  RETLW  4C
0237:  RETLW  8C
0238:  RETLW  44
0239:  RETLW  84
023A:  RETLW  85
023B:  RETLW  45
023C:  RETLW  87
023D:  RETLW  47
023E:  RETLW  46
023F:  RETLW  86
0240:  RETLW  82
0241:  RETLW  42
0242:  RETLW  43
0243:  RETLW  83
0244:  RETLW  41
0245:  RETLW  81
0246:  RETLW  80
0247:  RETLW  40
0248:  BCF    0A.0
0249:  BSF    0A.1
024A:  BCF    0A.2
024B:  ADDWF  02,F
024C:  RETLW  28
024D:  RETLW  7E
024E:  RETLW  31
024F:  RETLW  34
0250:  RETLW  66
0251:  RETLW  A4
0252:  RETLW  A0
0253:  RETLW  3E
0254:  RETLW  20
0255:  RETLW  24
0256:  RETLW  F7
0257:  RETLW  FF
0258:  RETLW  20
0259:  RETLW  A1
025A:  RETLW  F3
025B:  RETLW  E1
025C:  RETLW  FE
025D:  RETLW  62
025E:  RETLW  E9
025F:  RETLW  70
0260:  RETLW  E0
0261:  RETLW  A9
0262:  RETLW  28
0263:  RETLW  F8
0264:  RETLW  22
*
02F9:  BSF    03.6
02FA:  MOVF   43,W
02FB:  ANDLW  07
02FC:  MOVWF  77
02FD:  RRF    43,W
02FE:  MOVWF  78
02FF:  RRF    78,F
0300:  RRF    78,F
0301:  MOVLW  1F
0302:  ANDWF  78,F
0303:  MOVF   78,W
0304:  ADDWF  45,W
0305:  MOVWF  04
0306:  BCF    03.7
0307:  BTFSC  46.0
0308:  BSF    03.7
0309:  CLRF   78
030A:  INCF   78,F
030B:  INCF   77,F
030C:  GOTO   30E
030D:  RLF    78,F
030E:  DECFSZ 77,F
030F:  GOTO   30D
0310:  MOVF   44,F
0311:  BTFSC  03.2
0312:  GOTO   316
0313:  MOVF   78,W
0314:  IORWF  00,F
0315:  GOTO   319
0316:  COMF   78,F
0317:  MOVF   78,W
0318:  ANDWF  00,F
0319:  BCF    03.6
031A:  RETURN
*
03ED:  MOVLW  8E
03EE:  MOVWF  77
03EF:  BSF    03.6
03F0:  MOVF   33,W
03F1:  MOVWF  78
03F2:  MOVF   32,W
03F3:  MOVWF  79
03F4:  CLRF   7A
03F5:  MOVF   78,F
03F6:  BTFSS  03.2
03F7:  GOTO   402
03F8:  MOVF   79,W
03F9:  MOVWF  78
03FA:  CLRF   79
03FB:  MOVLW  08
03FC:  SUBWF  77,F
03FD:  MOVF   78,F
03FE:  BTFSS  03.2
03FF:  GOTO   402
0400:  CLRF   77
0401:  GOTO   40A
0402:  BCF    03.0
0403:  BTFSC  78.7
0404:  GOTO   409
0405:  RLF    79,F
0406:  RLF    78,F
0407:  DECF   77,F
0408:  GOTO   402
0409:  BCF    78.7
040A:  BCF    03.6
040B:  RETURN
040C:  BSF    03.6
040D:  MOVF   36,W
040E:  BTFSC  03.2
040F:  GOTO   4D2
0410:  MOVWF  42
0411:  MOVF   3A,W
0412:  BTFSC  03.2
0413:  GOTO   4D2
0414:  SUBWF  42,F
0415:  BTFSS  03.0
0416:  GOTO   41C
0417:  MOVLW  7F
0418:  ADDWF  42,F
0419:  BTFSC  03.0
041A:  GOTO   4D2
041B:  GOTO   422
041C:  MOVLW  81
041D:  SUBWF  42,F
041E:  BTFSS  03.0
041F:  GOTO   4D2
0420:  BTFSC  03.2
0421:  GOTO   4D2
0422:  MOVF   42,W
0423:  MOVWF  77
0424:  CLRF   78
0425:  CLRF   79
0426:  CLRF   7A
0427:  CLRF   41
0428:  MOVF   37,W
0429:  MOVWF  40
042A:  BSF    40.7
042B:  MOVF   38,W
042C:  MOVWF  3F
042D:  MOVF   39,W
042E:  MOVWF  3E
042F:  MOVLW  19
0430:  MOVWF  42
0431:  MOVF   3D,W
0432:  SUBWF  3E,F
0433:  BTFSC  03.0
0434:  GOTO   445
0435:  MOVLW  01
0436:  SUBWF  3F,F
0437:  BTFSC  03.0
0438:  GOTO   445
0439:  SUBWF  40,F
043A:  BTFSC  03.0
043B:  GOTO   445
043C:  SUBWF  41,F
043D:  BTFSC  03.0
043E:  GOTO   445
043F:  INCF   41,F
0440:  INCF   40,F
0441:  INCF   3F,F
0442:  MOVF   3D,W
0443:  ADDWF  3E,F
0444:  GOTO   477
0445:  MOVF   3C,W
0446:  SUBWF  3F,F
0447:  BTFSC  03.0
0448:  GOTO   460
0449:  MOVLW  01
044A:  SUBWF  40,F
044B:  BTFSC  03.0
044C:  GOTO   460
044D:  SUBWF  41,F
044E:  BTFSC  03.0
044F:  GOTO   460
0450:  INCF   41,F
0451:  INCF   40,F
0452:  MOVF   3C,W
0453:  ADDWF  3F,F
0454:  MOVF   3D,W
0455:  ADDWF  3E,F
0456:  BTFSS  03.0
0457:  GOTO   477
0458:  INCF   3F,F
0459:  BTFSS  03.2
045A:  GOTO   477
045B:  INCF   40,F
045C:  BTFSS  03.2
045D:  GOTO   477
045E:  INCF   41,F
045F:  GOTO   477
0460:  MOVF   3B,W
0461:  IORLW  80
0462:  SUBWF  40,F
0463:  BTFSC  03.0
0464:  GOTO   476
0465:  MOVLW  01
0466:  SUBWF  41,F
0467:  BTFSC  03.0
0468:  GOTO   476
0469:  INCF   41,F
046A:  MOVF   3B,W
046B:  IORLW  80
046C:  ADDWF  40,F
046D:  MOVF   3C,W
046E:  ADDWF  3F,F
046F:  BTFSS  03.0
0470:  GOTO   454
0471:  INCF   40,F
0472:  BTFSS  03.2
0473:  GOTO   454
0474:  INCF   41,F
0475:  GOTO   454
0476:  BSF    7A.0
0477:  DECFSZ 42,F
0478:  GOTO   47A
0479:  GOTO   485
047A:  BCF    03.0
047B:  RLF    3E,F
047C:  RLF    3F,F
047D:  RLF    40,F
047E:  RLF    41,F
047F:  BCF    03.0
0480:  RLF    7A,F
0481:  RLF    79,F
0482:  RLF    78,F
0483:  RLF    43,F
0484:  GOTO   431
0485:  BTFSS  43.0
0486:  GOTO   48D
0487:  BCF    03.0
0488:  RRF    78,F
0489:  RRF    79,F
048A:  RRF    7A,F
048B:  RRF    43,F
048C:  GOTO   490
048D:  DECF   77,F
048E:  BTFSC  03.2
048F:  GOTO   4D2
0490:  BTFSC  43.7
0491:  GOTO   4B9
0492:  BCF    03.0
0493:  RLF    3E,F
0494:  RLF    3F,F
0495:  RLF    40,F
0496:  RLF    41,F
0497:  MOVF   3D,W
0498:  SUBWF  3E,F
0499:  BTFSC  03.0
049A:  GOTO   4A5
049B:  MOVLW  01
049C:  SUBWF  3F,F
049D:  BTFSC  03.0
049E:  GOTO   4A5
049F:  SUBWF  40,F
04A0:  BTFSC  03.0
04A1:  GOTO   4A5
04A2:  SUBWF  41,F
04A3:  BTFSS  03.0
04A4:  GOTO   4C8
04A5:  MOVF   3C,W
04A6:  SUBWF  3F,F
04A7:  BTFSC  03.0
04A8:  GOTO   4B0
04A9:  MOVLW  01
04AA:  SUBWF  40,F
04AB:  BTFSC  03.0
04AC:  GOTO   4B0
04AD:  SUBWF  41,F
04AE:  BTFSS  03.0
04AF:  GOTO   4C8
04B0:  MOVF   3B,W
04B1:  IORLW  80
04B2:  SUBWF  40,F
04B3:  BTFSC  03.0
04B4:  GOTO   4B9
04B5:  MOVLW  01
04B6:  SUBWF  41,F
04B7:  BTFSS  03.0
04B8:  GOTO   4C8
04B9:  INCF   7A,F
04BA:  BTFSS  03.2
04BB:  GOTO   4C8
04BC:  INCF   79,F
04BD:  BTFSS  03.2
04BE:  GOTO   4C8
04BF:  INCF   78,F
04C0:  BTFSS  03.2
04C1:  GOTO   4C8
04C2:  INCF   77,F
04C3:  BTFSC  03.2
04C4:  GOTO   4D2
04C5:  RRF    78,F
04C6:  RRF    79,F
04C7:  RRF    7A,F
04C8:  MOVF   37,W
04C9:  MOVWF  42
04CA:  MOVF   3B,W
04CB:  XORWF  42,F
04CC:  BTFSS  42.7
04CD:  GOTO   4D0
04CE:  BSF    78.7
04CF:  GOTO   4D6
04D0:  BCF    78.7
04D1:  GOTO   4D6
04D2:  CLRF   77
04D3:  CLRF   78
04D4:  CLRF   79
04D5:  CLRF   7A
04D6:  BCF    03.6
04D7:  RETURN
04D8:  BSF    03.6
04D9:  MOVF   32,W
04DA:  BTFSC  03.2
04DB:  GOTO   549
04DC:  MOVWF  3A
04DD:  MOVF   36,W
04DE:  BTFSC  03.2
04DF:  GOTO   549
04E0:  ADDWF  3A,F
04E1:  BTFSC  03.0
04E2:  GOTO   4EA
04E3:  MOVLW  7F
04E4:  SUBWF  3A,F
04E5:  BTFSS  03.0
04E6:  GOTO   549
04E7:  BTFSC  03.2
04E8:  GOTO   549
04E9:  GOTO   4EE
04EA:  MOVLW  81
04EB:  ADDWF  3A,F
04EC:  BTFSC  03.0
04ED:  GOTO   549
04EE:  MOVF   3A,W
04EF:  MOVWF  77
04F0:  CLRF   78
04F1:  CLRF   79
04F2:  CLRF   7A
04F3:  MOVF   33,W
04F4:  MOVWF  3E
04F5:  BSF    3E.7
04F6:  MOVF   34,W
04F7:  MOVWF  3D
04F8:  MOVF   35,W
04F9:  MOVWF  3C
04FA:  MOVLW  18
04FB:  MOVWF  3A
04FC:  CLRF   3B
04FD:  BTFSS  3C.0
04FE:  GOTO   517
04FF:  MOVF   39,W
0500:  ADDWF  7A,F
0501:  BTFSS  03.0
0502:  GOTO   509
0503:  INCF   79,F
0504:  BTFSS  03.2
0505:  GOTO   509
0506:  INCF   78,F
0507:  BTFSC  03.2
0508:  BSF    3B.7
0509:  MOVF   38,W
050A:  ADDWF  79,F
050B:  BTFSS  03.0
050C:  GOTO   510
050D:  INCF   78,F
050E:  BTFSC  03.2
050F:  BSF    3B.7
0510:  MOVF   37,W
0511:  MOVWF  34
0512:  BSF    34.7
0513:  MOVF   34,W
0514:  ADDWF  78,F
0515:  BTFSC  03.0
0516:  BSF    3B.7
0517:  RLF    3B,F
0518:  RRF    78,F
0519:  RRF    79,F
051A:  RRF    7A,F
051B:  RRF    3E,F
051C:  RRF    3D,F
051D:  RRF    3C,F
051E:  BCF    03.0
051F:  DECFSZ 3A,F
0520:  GOTO   4FC
0521:  MOVLW  01
0522:  ADDWF  77,F
0523:  BTFSC  03.0
0524:  GOTO   549
0525:  BTFSC  78.7
0526:  GOTO   52E
0527:  RLF    3E,F
0528:  RLF    7A,F
0529:  RLF    79,F
052A:  RLF    78,F
052B:  DECF   77,F
052C:  BTFSC  03.2
052D:  GOTO   549
052E:  BTFSS  3E.7
052F:  GOTO   53F
0530:  INCF   7A,F
0531:  BTFSS  03.2
0532:  GOTO   53F
0533:  INCF   79,F
0534:  BTFSS  03.2
0535:  GOTO   53F
0536:  INCF   78,F
0537:  BTFSS  03.2
0538:  GOTO   53F
0539:  RRF    78,F
053A:  RRF    79,F
053B:  RRF    7A,F
053C:  INCF   77,F
053D:  BTFSC  03.2
053E:  GOTO   549
053F:  MOVF   33,W
0540:  MOVWF  3B
0541:  MOVF   37,W
0542:  XORWF  3B,F
0543:  BTFSS  3B.7
0544:  GOTO   547
0545:  BSF    78.7
0546:  GOTO   54D
0547:  BCF    78.7
0548:  GOTO   54D
0549:  CLRF   77
054A:  CLRF   78
054B:  CLRF   79
054C:  CLRF   7A
054D:  BCF    03.6
054E:  RETURN
054F:  MOVLW  80
0550:  BTFSS  03.1
0551:  GOTO   555
0552:  BSF    03.6
0553:  XORWF  3B,F
0554:  BCF    03.6
0555:  BSF    03.6
0556:  CLRF   40
0557:  CLRF   41
0558:  MOVF   37,W
0559:  MOVWF  3F
055A:  MOVF   3B,W
055B:  XORWF  3F,F
055C:  MOVF   36,W
055D:  BTFSC  03.2
055E:  GOTO   643
055F:  MOVWF  3E
0560:  MOVWF  77
0561:  MOVF   3A,W
0562:  BTFSC  03.2
0563:  GOTO   64C
0564:  SUBWF  3E,F
0565:  BTFSC  03.2
0566:  GOTO   5E8
0567:  BTFSS  03.0
0568:  GOTO   5A6
0569:  MOVF   3B,W
056A:  MOVWF  44
056B:  BSF    44.7
056C:  MOVF   3C,W
056D:  MOVWF  43
056E:  MOVF   3D,W
056F:  MOVWF  42
0570:  CLRF   41
0571:  BCF    03.0
0572:  RRF    44,F
0573:  RRF    43,F
0574:  RRF    42,F
0575:  RRF    41,F
0576:  DECFSZ 3E,F
0577:  GOTO   570
0578:  BTFSS  3F.7
0579:  GOTO   57D
057A:  BSF    40.0
057B:  GOTO   660
057C:  BCF    40.0
057D:  BCF    3E.0
057E:  BSF    40.4
057F:  MOVLW  39
0580:  MOVWF  04
0581:  BSF    03.7
0582:  GOTO   675
0583:  BCF    40.4
0584:  BTFSC  3F.7
0585:  GOTO   590
0586:  BTFSS  3E.0
0587:  GOTO   59B
0588:  RRF    44,F
0589:  RRF    43,F
058A:  RRF    42,F
058B:  RRF    41,F
058C:  INCF   77,F
058D:  BTFSC  03.2
058E:  GOTO   65B
058F:  GOTO   59B
0590:  BTFSC  44.7
0591:  GOTO   59E
0592:  BCF    03.0
0593:  RLF    41,F
0594:  RLF    42,F
0595:  RLF    43,F
0596:  RLF    44,F
0597:  DECF   77,F
0598:  BTFSC  03.2
0599:  GOTO   65B
059A:  GOTO   590
059B:  BSF    40.6
059C:  GOTO   608
059D:  BCF    40.6
059E:  MOVF   37,W
059F:  MOVWF  3F
05A0:  BTFSS  3F.7
05A1:  GOTO   5A4
05A2:  BSF    44.7
05A3:  GOTO   654
05A4:  BCF    44.7
05A5:  GOTO   654
05A6:  MOVF   3A,W
05A7:  MOVWF  3E
05A8:  MOVWF  77
05A9:  MOVF   36,W
05AA:  SUBWF  3E,F
05AB:  MOVF   37,W
05AC:  MOVWF  44
05AD:  BSF    44.7
05AE:  MOVF   38,W
05AF:  MOVWF  43
05B0:  MOVF   39,W
05B1:  MOVWF  42
05B2:  CLRF   41
05B3:  BCF    03.0
05B4:  RRF    44,F
05B5:  RRF    43,F
05B6:  RRF    42,F
05B7:  RRF    41,F
05B8:  DECFSZ 3E,F
05B9:  GOTO   5B2
05BA:  BTFSS  3F.7
05BB:  GOTO   5BF
05BC:  BSF    40.1
05BD:  GOTO   660
05BE:  BCF    40.1
05BF:  BCF    3E.0
05C0:  BSF    40.5
05C1:  MOVLW  3D
05C2:  MOVWF  04
05C3:  BSF    03.7
05C4:  GOTO   675
05C5:  BCF    40.5
05C6:  BTFSC  3F.7
05C7:  GOTO   5D2
05C8:  BTFSS  3E.0
05C9:  GOTO   5DD
05CA:  RRF    44,F
05CB:  RRF    43,F
05CC:  RRF    42,F
05CD:  RRF    41,F
05CE:  INCF   77,F
05CF:  BTFSC  03.2
05D0:  GOTO   65B
05D1:  GOTO   5DD
05D2:  BTFSC  44.7
05D3:  GOTO   5E0
05D4:  BCF    03.0
05D5:  RLF    41,F
05D6:  RLF    42,F
05D7:  RLF    43,F
05D8:  RLF    44,F
05D9:  DECF   77,F
05DA:  BTFSC  03.2
05DB:  GOTO   65B
05DC:  GOTO   5D2
05DD:  BSF    40.7
05DE:  GOTO   608
05DF:  BCF    40.7
05E0:  MOVF   3B,W
05E1:  MOVWF  3F
05E2:  BTFSS  3F.7
05E3:  GOTO   5E6
05E4:  BSF    44.7
05E5:  GOTO   654
05E6:  BCF    44.7
05E7:  GOTO   654
05E8:  MOVF   3B,W
05E9:  MOVWF  44
05EA:  BSF    44.7
05EB:  MOVF   3C,W
05EC:  MOVWF  43
05ED:  MOVF   3D,W
05EE:  MOVWF  42
05EF:  BTFSS  3F.7
05F0:  GOTO   5F5
05F1:  BCF    44.7
05F2:  BSF    40.2
05F3:  GOTO   660
05F4:  BCF    40.2
05F5:  CLRF   41
05F6:  BCF    3E.0
05F7:  MOVLW  39
05F8:  MOVWF  04
05F9:  BSF    03.7
05FA:  GOTO   675
05FB:  BTFSC  3F.7
05FC:  GOTO   61E
05FD:  MOVF   37,W
05FE:  MOVWF  3F
05FF:  BTFSS  3E.0
0600:  GOTO   608
0601:  RRF    44,F
0602:  RRF    43,F
0603:  RRF    42,F
0604:  RRF    41,F
0605:  INCF   77,F
0606:  BTFSC  03.2
0607:  GOTO   65B
0608:  BTFSS  41.7
0609:  GOTO   619
060A:  INCF   42,F
060B:  BTFSS  03.2
060C:  GOTO   619
060D:  INCF   43,F
060E:  BTFSS  03.2
060F:  GOTO   619
0610:  INCF   44,F
0611:  BTFSS  03.2
0612:  GOTO   619
0613:  RRF    44,F
0614:  RRF    43,F
0615:  RRF    42,F
0616:  INCF   77,F
0617:  BTFSC  03.2
0618:  GOTO   65B
0619:  BTFSC  40.6
061A:  GOTO   59D
061B:  BTFSC  40.7
061C:  GOTO   5DF
061D:  GOTO   63D
061E:  MOVLW  80
061F:  XORWF  44,F
0620:  BTFSS  44.7
0621:  GOTO   626
0622:  GOTO   660
0623:  MOVF   3B,W
0624:  MOVWF  3F
0625:  GOTO   633
0626:  MOVF   37,W
0627:  MOVWF  3F
0628:  MOVF   44,F
0629:  BTFSS  03.2
062A:  GOTO   633
062B:  MOVF   43,F
062C:  BTFSS  03.2
062D:  GOTO   633
062E:  MOVF   42,F
062F:  BTFSS  03.2
0630:  GOTO   633
0631:  CLRF   77
0632:  GOTO   654
0633:  BTFSC  44.7
0634:  GOTO   63D
0635:  BCF    03.0
0636:  RLF    41,F
0637:  RLF    42,F
0638:  RLF    43,F
0639:  RLF    44,F
063A:  DECFSZ 77,F
063B:  GOTO   633
063C:  GOTO   65B
063D:  BTFSS  3F.7
063E:  GOTO   641
063F:  BSF    44.7
0640:  GOTO   654
0641:  BCF    44.7
0642:  GOTO   654
0643:  MOVF   3A,W
0644:  MOVWF  77
0645:  MOVF   3B,W
0646:  MOVWF  44
0647:  MOVF   3C,W
0648:  MOVWF  43
0649:  MOVF   3D,W
064A:  MOVWF  42
064B:  GOTO   654
064C:  MOVF   36,W
064D:  MOVWF  77
064E:  MOVF   37,W
064F:  MOVWF  44
0650:  MOVF   38,W
0651:  MOVWF  43
0652:  MOVF   39,W
0653:  MOVWF  42
0654:  MOVF   44,W
0655:  MOVWF  78
0656:  MOVF   43,W
0657:  MOVWF  79
0658:  MOVF   42,W
0659:  MOVWF  7A
065A:  GOTO   693
065B:  CLRF   77
065C:  CLRF   78
065D:  CLRF   79
065E:  CLRF   7A
065F:  GOTO   693
0660:  CLRF   41
0661:  COMF   42,F
0662:  COMF   43,F
0663:  COMF   44,F
0664:  COMF   41,F
0665:  INCF   41,F
0666:  BTFSS  03.2
0667:  GOTO   66E
0668:  INCF   42,F
0669:  BTFSS  03.2
066A:  GOTO   66E
066B:  INCF   43,F
066C:  BTFSC  03.2
066D:  INCF   44,F
066E:  BTFSC  40.0
066F:  GOTO   57C
0670:  BTFSC  40.1
0671:  GOTO   5BE
0672:  BTFSC  40.2
0673:  GOTO   5F4
0674:  GOTO   623
0675:  MOVF   00,W
0676:  ADDWF  42,F
0677:  BTFSS  03.0
0678:  GOTO   67F
0679:  INCF   43,F
067A:  BTFSS  03.2
067B:  GOTO   67F
067C:  INCF   44,F
067D:  BTFSC  03.2
067E:  BSF    3E.0
067F:  DECF   04,F
0680:  MOVF   00,W
0681:  ADDWF  43,F
0682:  BTFSS  03.0
0683:  GOTO   687
0684:  INCF   44,F
0685:  BTFSC  03.2
0686:  BSF    3E.0
0687:  DECF   04,F
0688:  MOVF   00,W
0689:  BTFSS  00.7
068A:  XORLW  80
068B:  ADDWF  44,F
068C:  BTFSC  03.0
068D:  BSF    3E.0
068E:  BTFSC  40.4
068F:  GOTO   583
0690:  BTFSC  40.5
0691:  GOTO   5C5
0692:  GOTO   5FB
0693:  BCF    03.6
0694:  RETURN
0695:  BSF    03.6
0696:  MOVF   37,W
0697:  MOVWF  3E
0698:  MOVF   3B,W
0699:  XORWF  3E,F
069A:  BTFSS  3E.7
069B:  GOTO   6A1
069C:  BCF    03.2
069D:  BCF    03.0
069E:  BTFSC  37.7
069F:  BSF    03.0
06A0:  GOTO   6D4
06A1:  MOVF   37,W
06A2:  MOVWF  3E
06A3:  MOVF   3A,W
06A4:  MOVWF  3F
06A5:  MOVF   36,W
06A6:  SUBWF  3F,F
06A7:  BTFSC  03.2
06A8:  GOTO   6AF
06A9:  BTFSS  3E.7
06AA:  GOTO   6D4
06AB:  MOVF   03,W
06AC:  XORLW  01
06AD:  MOVWF  03
06AE:  GOTO   6D4
06AF:  MOVF   3B,W
06B0:  MOVWF  3F
06B1:  MOVF   37,W
06B2:  SUBWF  3F,F
06B3:  BTFSC  03.2
06B4:  GOTO   6BB
06B5:  BTFSS  3E.7
06B6:  GOTO   6D4
06B7:  MOVF   03,W
06B8:  XORLW  01
06B9:  MOVWF  03
06BA:  GOTO   6D4
06BB:  MOVF   3C,W
06BC:  MOVWF  3F
06BD:  MOVF   38,W
06BE:  SUBWF  3F,F
06BF:  BTFSC  03.2
06C0:  GOTO   6C7
06C1:  BTFSS  3E.7
06C2:  GOTO   6D4
06C3:  MOVF   03,W
06C4:  XORLW  01
06C5:  MOVWF  03
06C6:  GOTO   6D4
06C7:  MOVF   3D,W
06C8:  MOVWF  3F
06C9:  MOVF   39,W
06CA:  SUBWF  3F,F
06CB:  BTFSC  03.2
06CC:  GOTO   6D3
06CD:  BTFSS  3E.7
06CE:  GOTO   6D4
06CF:  MOVF   03,W
06D0:  XORLW  01
06D1:  MOVWF  03
06D2:  GOTO   6D4
06D3:  BCF    03.0
06D4:  BCF    03.6
06D5:  RETURN
06D6:  MOVLW  8E
06D7:  MOVWF  77
06D8:  BSF    03.6
06D9:  MOVF   32,W
06DA:  SUBWF  77,F
06DB:  MOVF   33,W
06DC:  MOVWF  79
06DD:  MOVF   34,W
06DE:  MOVWF  78
06DF:  BSF    79.7
06E0:  MOVF   77,F
06E1:  BTFSC  03.2
06E2:  GOTO   6EE
06E3:  BCF    03.0
06E4:  MOVF   79,F
06E5:  BTFSS  03.2
06E6:  GOTO   6EA
06E7:  MOVF   78,F
06E8:  BTFSC  03.2
06E9:  GOTO   6EE
06EA:  RRF    79,F
06EB:  RRF    78,F
06EC:  DECFSZ 77,F
06ED:  GOTO   6E3
06EE:  BTFSS  33.7
06EF:  GOTO   6F5
06F0:  COMF   78,F
06F1:  COMF   79,F
06F2:  INCF   78,F
06F3:  BTFSC  03.2
06F4:  INCF   79,F
06F5:  BCF    03.6
06F6:  RETURN
06F7:  BSF    03.6
06F8:  MOVF   34,W
06F9:  CLRF   78
06FA:  SUBWF  33,W
06FB:  BTFSC  03.0
06FC:  GOTO   700
06FD:  MOVF   33,W
06FE:  MOVWF  77
06FF:  GOTO   70C
0700:  CLRF   77
0701:  MOVLW  08
0702:  MOVWF  35
0703:  RLF    33,F
0704:  RLF    77,F
0705:  MOVF   34,W
0706:  SUBWF  77,W
0707:  BTFSC  03.0
0708:  MOVWF  77
0709:  RLF    78,F
070A:  DECFSZ 35,F
070B:  GOTO   703
070C:  BCF    03.6
070D:  RETURN
070E:  CLRF   78
070F:  CLRF   79
0710:  CLRF   77
0711:  CLRF   7A
0712:  BSF    03.6
0713:  MOVF   37,W
0714:  BTFSS  03.2
0715:  GOTO   719
0716:  MOVF   36,W
0717:  BTFSC  03.2
0718:  GOTO   733
0719:  MOVLW  10
071A:  MOVWF  38
071B:  BCF    03.0
071C:  RLF    34,F
071D:  RLF    35,F
071E:  RLF    77,F
071F:  RLF    7A,F
0720:  MOVF   37,W
0721:  SUBWF  7A,W
0722:  BTFSS  03.2
0723:  GOTO   726
0724:  MOVF   36,W
0725:  SUBWF  77,W
0726:  BTFSS  03.0
0727:  GOTO   72F
0728:  MOVF   36,W
0729:  SUBWF  77,F
072A:  BTFSS  03.0
072B:  DECF   7A,F
072C:  MOVF   37,W
072D:  SUBWF  7A,F
072E:  BSF    03.0
072F:  RLF    78,F
0730:  RLF    79,F
0731:  DECFSZ 38,F
0732:  GOTO   71B
0733:  BCF    03.6
0734:  RETURN
*
07C8:  CLRF   77
07C9:  CLRF   78
07CA:  BSF    03.6
07CB:  MOVF   33,W
07CC:  BCF    03.0
07CD:  BTFSC  34.0
07CE:  ADDWF  77,F
07CF:  RRF    77,F
07D0:  RRF    78,F
07D1:  BTFSC  34.1
07D2:  ADDWF  77,F
07D3:  RRF    77,F
07D4:  RRF    78,F
07D5:  BTFSC  34.2
07D6:  ADDWF  77,F
07D7:  RRF    77,F
07D8:  RRF    78,F
07D9:  BTFSC  34.3
07DA:  ADDWF  77,F
07DB:  RRF    77,F
07DC:  RRF    78,F
07DD:  BTFSC  34.4
07DE:  ADDWF  77,F
07DF:  RRF    77,F
07E0:  RRF    78,F
07E1:  BTFSC  34.5
07E2:  ADDWF  77,F
07E3:  RRF    77,F
07E4:  RRF    78,F
07E5:  BTFSC  34.6
07E6:  ADDWF  77,F
07E7:  RRF    77,F
07E8:  RRF    78,F
07E9:  BTFSC  34.7
07EA:  ADDWF  77,F
07EB:  RRF    77,F
07EC:  RRF    78,F
07ED:  BCF    03.6
07EE:  RETURN
*
0EFD:  MOVLW  8E
0EFE:  MOVWF  77
0EFF:  BSF    03.6
0F00:  MOVF   37,W
0F01:  MOVWF  78
0F02:  MOVF   36,W
0F03:  MOVWF  79
0F04:  CLRF   7A
0F05:  BTFSS  37.7
0F06:  GOTO   70C
0F07:  COMF   78,F
0F08:  COMF   79,F
0F09:  INCF   79,F
0F0A:  BTFSC  03.2
0F0B:  INCF   78,F
0F0C:  MOVF   78,F
0F0D:  BTFSS  03.2
0F0E:  GOTO   719
0F0F:  MOVF   79,W
0F10:  MOVWF  78
0F11:  CLRF   79
0F12:  MOVLW  08
0F13:  SUBWF  77,F
0F14:  MOVF   78,F
0F15:  BTFSS  03.2
0F16:  GOTO   719
0F17:  CLRF   77
0F18:  GOTO   722
0F19:  BCF    03.0
0F1A:  BTFSC  78.7
0F1B:  GOTO   720
0F1C:  RLF    79,F
0F1D:  RLF    78,F
0F1E:  DECF   77,F
0F1F:  GOTO   719
0F20:  BTFSS  37.7
0F21:  BCF    78.7
0F22:  BCF    03.6
0F23:  RETURN
*
0FD2:  BSF    03.6
0FD3:  MOVF   33,W
0FD4:  XORWF  34,W
0FD5:  ANDLW  80
0FD6:  MOVWF  36
0FD7:  BTFSS  33.7
0FD8:  GOTO   7DB
0FD9:  COMF   33,F
0FDA:  INCF   33,F
0FDB:  BTFSS  34.7
0FDC:  GOTO   7DF
0FDD:  COMF   34,F
0FDE:  INCF   34,F
0FDF:  MOVF   34,W
0FE0:  CLRF   78
0FE1:  SUBWF  33,W
0FE2:  BTFSC  03.0
0FE3:  GOTO   7E7
0FE4:  MOVF   33,W
0FE5:  MOVWF  77
0FE6:  GOTO   7F3
0FE7:  CLRF   77
0FE8:  MOVLW  08
0FE9:  MOVWF  35
0FEA:  RLF    33,F
0FEB:  RLF    77,F
0FEC:  MOVF   34,W
0FED:  SUBWF  77,W
0FEE:  BTFSC  03.0
0FEF:  MOVWF  77
0FF0:  RLF    78,F
0FF1:  DECFSZ 35,F
0FF2:  GOTO   7EA
0FF3:  BTFSS  36.7
0FF4:  GOTO   7F7
0FF5:  COMF   78,F
0FF6:  INCF   78,F
0FF7:  BCF    03.6
0FF8:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses WDT, HS, NOPUT,PROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD
.................... #use delay (clock=20000000)
*
034A:  MOVLW  03
034B:  BSF    03.6
034C:  SUBWF  40,F
034D:  BTFSS  03.0
034E:  GOTO   359
034F:  MOVLW  40
0350:  MOVWF  04
0351:  BSF    03.7
0352:  MOVF   00,W
0353:  BTFSC  03.2
0354:  GOTO   359
0355:  GOTO   357
0356:  GOTO   357
0357:  DECFSZ 00,F
0358:  GOTO   356
0359:  BCF    03.6
035A:  RETURN
*
0791:  MOVLW  3F
0792:  MOVWF  04
0793:  BSF    03.7
0794:  MOVF   00,W
0795:  BTFSC  03.2
0796:  GOTO   7A4
0797:  MOVLW  06
0798:  MOVWF  78
0799:  CLRF   77
079A:  DECFSZ 77,F
079B:  GOTO   79A
079C:  DECFSZ 78,F
079D:  GOTO   799
079E:  MOVLW  7B
079F:  MOVWF  77
07A0:  DECFSZ 77,F
07A1:  GOTO   7A0
07A2:  DECFSZ 00,F
07A3:  GOTO   797
07A4:  RETURN
.................... #use fast_io(a)
.................... #use fast_io(b)
.................... #use fast_io(d)
.................... const int8 MAXNUM=4;//num of sev_segs
.................... int8 i=0,m=0;
.................... int1 daucham=0,Modbus_update=0,Ghi_Rom=0;
.................... int8 control_array[3]={Pin_A0,Pin_A1,Pin_A2};
*
1CDC:  MOVLW  28
1CDD:  BCF    03.6
1CDE:  MOVWF  2B
1CDF:  MOVLW  29
1CE0:  MOVWF  2C
1CE1:  MOVLW  2A
1CE2:  MOVWF  2D
.................... int1 Old_Mode=0,Old_Alarm=0,alarmACK=0;
.................... int8 canhbao=0,set_count=0,Config=0;
.................... float Temp_offset=0,deadband=0;
.................... signed int8 high_temp=0,low_temp=0;
.................... int8 nhapnhay=0,Delay_ReadTemp=0;
.................... int1 Count_ReadTemp=0;
.................... //PACK FOR NEW CLOCK
.................... int8 main_array[MAXNUM]={0,0,0,0};
1CE3:  CLRF   3D
1CE4:  CLRF   3E
1CE5:  CLRF   3F
1CE6:  CLRF   40
.................... int8 temp_array[MAXNUM]={0,0,0,0};
1CE7:  CLRF   41
1CE8:  CLRF   42
1CE9:  CLRF   43
1CEA:  CLRF   44
.................... int1 alarmbit[2]={0,0},Led_Alarm=0;
1CEB:  CLRF   45
.................... #include <modbus_slave.c>
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //                                         CAC DINH NGHIA VA THU VIEN CHO MODBUS                                                 //
.................... //                                                                                                                               //
....................    #define MODBUS_ADDRESS 50//Add of MobusSlave, range: 0-->247
....................    #define MODBUS_TYPE MODBUS_TYPE_SLAVE
....................    #define MODBUS_SERIAL_TYPE MODBUS_RTU     //use MODBUS_ASCII for ASCII mode
....................    #define MODBUS_SERIAL_RX_BUFFER_SIZE 64
....................    #define MODBUS_SERIAL_BAUD 9600
....................    //Nguon ngat PC to MCU (Pic)
....................    #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA
....................    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................    //                                              KHAI BAO PIN OUT                                                                 //
....................    //                                                                                                                               //
....................    #define MODBUS_SERIAL_ENABLE_PIN   PIN_C5   // Controls DE pin for RS485
....................    #define MODBUS_SERIAL_RX_ENABLE    PIN_C5   // Controls RE pin for RS485                                                         
....................                                                                                                                                  //
....................    //                                                                                                                               //
....................    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
....................    #include <MODBUS_LIBRARY.c> //Thu vien chuan cua CCS-C     
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                      modbus.c                                    ////
.................... ////                                                                                  ////
.................... ////                 MODBUS protocol driver for serial communications.                ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////                                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   ////
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               ////
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// SHARED API:                                                                      ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //// MASTER API:                                                                      ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////                                                                                  ////
.................... //// Slave API:                                                                       ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  May 8, 2009       Made PCD Compatible                                           ////
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2006 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE  88888
.................... #define MODBUS_INT_RDA     77777
.................... #define MODBUS_INT_RDA2    66666
.................... #define MODBUS_INT_RDA3    44444
.................... #define MODBUS_INT_RDA4    33333
.................... #define MODBUS_INT_EXT     55555
.................... #define MODBUS_RTU         1
.................... #define MODBUS_ASCII       2
.................... 
.................... #ifndef MODBUS_TYPE
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_TYPE
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_INT_SOURCE
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt
.................... #endif                                             // or asynchronous serial interrupt
.................... 
.................... #ifndef MODBUS_SERIAL_BAUD
.................... #define MODBUS_SERIAL_BAUD 9600
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_RX_PIN
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_TX_PIN
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high.
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_RX_ENABLE
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low.
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_TIMEOUT
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................       #define MODBUS_SERIAL_TIMEOUT    1000000
....................    #else
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us
....................    #endif
.................... #endif
.................... 
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA )
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors)
*
0294:  BTFSS  0C.5
0295:  GOTO   294
0296:  MOVF   18,W
0297:  MOVWF  46
0298:  MOVF   1A,W
0299:  MOVWF  78
029A:  BTFSS  46.1
029B:  GOTO   29E
029C:  BCF    18.4
029D:  BSF    18.4
029E:  RETURN
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 )
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 )
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 )
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors)
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT )
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints)
....................    #if defined(__PCD__)
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);}
....................    #else
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);}
....................    #endif
.................... #else
....................    #error Please define a correct interrupt source
.................... #endif
.................... 
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer
.................... #endif
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................     if(address)\
....................     {\
....................         while(!modbus_kbhit() && --modbus_serial_wait)\
....................             delay_us(1);\
....................         if(!modbus_serial_wait)\
....................             modbus_rx.error=TIMEOUT;\
....................     }\
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................          #else
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #byte TXSTA=getenv("sfr:TXSTA2")
....................       #endif
....................       #bit TRMT=TXSTA.1
....................    #endif
.................... 
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }   
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.  
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
....................     
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII)
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0;
.................... #else
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... #endif
.................... 
.................... /*Global value holding our current CRC value.*/
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII)
....................    unsigned int8 modbus_serial_lrc;
.................... #else
....................    union
....................    {
....................       int8 b[2];
....................       int16 d;
....................    } modbus_serial_crc;
.................... #endif
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    int8 address;
....................    int8 len;                                //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... /* Table of CRC values for highorder byte */
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... #endif
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void)
.................... {
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................       while(kbhit(MODBUS_SERIAL)) {getc();}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
*
07A5:  BTFSS  0C.5
07A6:  GOTO   7A9
07A7:  CALL   294
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
07A8:  GOTO   7A5
....................         clear_interrupt(INT_RDA);
07A9:  MOVF   1A,W
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
....................         clear_interrupt(INT_RDA2);
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
....................         clear_interrupt(INT_RDA3);
....................       #else
....................         clear_interrupt(INT_RDA4);
....................       #endif
.................... 
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE);
07AA:  BCF    4B.5
07AB:  MOVF   4B,W
07AC:  BSF    03.5
07AD:  MOVWF  07
07AE:  BCF    03.5
07AF:  BCF    07.5
....................       #endif
.................... 
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
....................         enable_interrupts(INT_RDA);
07B0:  BSF    03.5
07B1:  BSF    0C.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
....................         enable_interrupts(INT_RDA2);
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
....................         enable_interrupts(INT_RDA3);
....................       #else
....................         enable_interrupts(INT_RDA4);
....................       #endif
....................    #else
07B2:  BCF    03.5
07B3:  RETURN
....................       #if defined(__PCD__)
....................          clear_interrupt(INT_EXT0);
....................       #else
....................          clear_interrupt(INT_EXT);
....................       #endif
....................       
....................       ext_int_edge(H_TO_L);
....................      
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE);
....................       #endif
.................... 
....................       #if defined(__PCD__)
....................          enable_interrupts(INT_EXT0);
....................       #else
....................          enable_interrupts(INT_EXT);
....................       #endif
....................    #endif
.................... }
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
07B4:  BCF    4B.5
07B5:  MOVF   4B,W
07B6:  BSF    03.5
07B7:  MOVWF  07
07B8:  BCF    03.5
07B9:  BCF    07.5
.................... 
....................    RCV_ON();
07BA:  CALL   7A5
.................... 
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock
....................       #endif
....................       enable_interrupts(INTR_GLOBAL);
....................    #else
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts
07BB:  MOVLW  20
07BC:  MOVWF  78
07BD:  IORLW  06
07BE:  MOVWF  12
07BF:  MOVLW  F9
07C0:  BSF    03.5
07C1:  MOVWF  12
....................       #endif
....................       enable_interrupts(GLOBAL);
07C2:  MOVLW  C0
07C3:  BCF    03.5
07C4:  IORWF  0B,F
....................    #endif
07C5:  BSF    0A.3
07C6:  BSF    0A.4
07C7:  GOTO   585 (RETURN)
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    disable_interrupts(INT_TIMER2);
*
0265:  BSF    03.5
0266:  BCF    0C.1
....................    if (enable) {
0267:  BCF    03.5
0268:  BSF    03.6
0269:  MOVF   4A,F
026A:  BTFSC  03.2
026B:  GOTO   273
....................       set_timer2(0);
026C:  BCF    03.6
026D:  CLRF   11
....................       clear_interrupt(INT_TIMER2);
026E:  BCF    0C.1
....................       enable_interrupts(INT_TIMER2);
026F:  BSF    03.5
0270:  BSF    0C.1
0271:  BCF    03.5
0272:  BSF    03.6
....................    }
0273:  BCF    03.6
0274:  RETURN
.................... }
.................... #endif
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................    #int_timer2
....................    void modbus_timeout_now(void)
....................    {
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
0275:  MOVF   48,W
0276:  SUBLW  02
0277:  BTFSS  03.2
0278:  GOTO   287
0279:  MOVF   49,F
027A:  BTFSS  03.2
027B:  GOTO   287
027C:  MOVF   4A,F
027D:  BTFSS  03.2
027E:  GOTO   287
027F:  BTFSC  47.0
0280:  GOTO   287
....................       {
....................          modbus_rx.len-=2;
0281:  MOVLW  02
0282:  BSF    03.5
0283:  SUBWF  21,F
....................          modbus_serial_new=TRUE;
0284:  BCF    03.5
0285:  BSF    47.0
....................       }
0286:  GOTO   288
....................       else
....................          modbus_serial_new=FALSE;
0287:  BCF    47.0
....................    
....................       modbus_serial_crc.d=0xFFFF;
0288:  MOVLW  FF
0289:  MOVWF  4A
028A:  MOVWF  49
....................       modbus_serial_state=MODBUS_GETADDY;
028B:  CLRF   48
....................       modbus_enable_timeout(FALSE);
028C:  BSF    03.6
028D:  CLRF   4A
028E:  BCF    03.6
028F:  CALL   265
....................    }
0290:  BCF    0C.1
0291:  BCF    0A.3
0292:  BCF    0A.4
0293:  GOTO   023
.................... #endif
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................       modbus_serial_lrc+=data;
....................    #else
....................       unsigned int8 uIndex ; // will index into CRC lookup table
.................... 
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
029F:  MOVF   4A,W
02A0:  BSF    03.6
02A1:  XORWF  4A,W
02A2:  MOVWF  4B
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
02A3:  MOVF   4B,W
02A4:  BCF    03.6
02A5:  CALL   03A
02A6:  MOVWF  78
02A7:  MOVF   49,W
02A8:  XORWF  78,W
02A9:  MOVWF  4A
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
02AA:  BSF    03.6
02AB:  MOVF   4B,W
02AC:  BCF    03.6
02AD:  CALL   141
02AE:  MOVWF  78
02AF:  MOVWF  49
....................    #endif
02B0:  RETURN
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(int8 c)
.................... {
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII)
....................       int8 asciih,asciil;
....................       
....................       asciih=c>>4;
....................       if(asciih>9)
....................          asciih+=0x37;
....................       else
....................          asciih+=0x30;
....................       asciil=c&0xF;
....................       if(asciil>9)
....................          asciil+=0x37;
....................       else
....................          asciil+=0x30;
....................       fputc(asciih,MODBUS_SERIAL);
....................       fputc(asciil,MODBUS_SERIAL);
....................       modbus_calc_crc(c);
....................    #else
....................       fputc(c, MODBUS_SERIAL);
*
0E81:  BSF    03.6
0E82:  MOVF   3F,W
0E83:  BCF    03.6
0E84:  BTFSS  0C.4
0E85:  GOTO   684
0E86:  MOVWF  19
0E87:  CLRF   27
0E88:  BTFSC  0B.7
0E89:  BSF    27.7
0E8A:  BCF    0B.7
....................       modbus_calc_crc(c);
0E8B:  BSF    03.6
0E8C:  MOVF   3F,W
0E8D:  MOVWF  4A
0E8E:  BCF    0A.3
0E8F:  BCF    03.6
0E90:  CALL   29F
0E91:  BSF    0A.3
0E92:  BTFSC  27.7
0E93:  BSF    0B.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
0E94:  MOVLW  AD
0E95:  MOVWF  77
0E96:  DECFSZ 77,F
0E97:  GOTO   696
....................    #endif
0E98:  RETURN
.................... }
.................... 
.................... // Purpose:   Interrupt service routine for handling incoming serial data
.................... // Inputs:    None
.................... // Outputs:   None
.................... //Khai bao ngat cho viec nhan du lieu tu Master-->Slave hoac nguoc lai.
.................... //Khi ngat la RDA thi Master la PC
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
.................... #int_rda3
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4)
.................... #int_rda4
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #if defined(__PCD__)
.................... #int_ext0
.................... #else
.................... #int_ext
.................... #endif
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII)
....................       static int1 two_characters=0;
....................       static int8 datah,datal,data;
....................    #endif
.................... 
....................    c=fgetc(MODBUS_SERIAL);
*
02B1:  CALL   294
02B2:  MOVF   78,W
02B3:  BSF    03.6
02B4:  MOVWF  49
....................    
....................    if (!modbus_serial_new)
02B5:  BCF    03.6
02B6:  BTFSC  47.0
02B7:  GOTO   2F5
....................    {
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII)
....................          if(modbus_serial_state == MODBUS_START)
....................          {
....................             if(c==':')
....................                modbus_serial_state++;
....................          }
....................          else if(modbus_serial_state == MODBUS_GETADDY)
....................          {
....................             if(!two_characters)
....................             {
....................                if(c>=0x41)
....................                   datah=((c-0x37)<<4);
....................                else
....................                   datah=((c-0x30)<<4);
....................                modbus_serial_lrc=0;
....................             }
....................             else
....................             {
....................                if(c>=0x41)
....................                   datal=c-0x37;
....................                else
....................                   datal=c-0x30;
....................                data=(datah | datal);
....................                modbus_rx.address=data;
....................                modbus_calc_crc(data);
....................                modbus_serial_state++;
....................             }
....................             two_characters++;
....................          }
....................          else if(modbus_serial_state == MODBUS_GETFUNC)
....................          {
....................             if(!two_characters)
....................             {
....................                if(c>=0x41)
....................                   datah=((c-0x37)<<4);
....................                else
....................                   datah=((c-0x30)<<4);
....................             }
....................             else
....................             {
....................                if(c>=0x41)
....................                   datal=c-0x37;
....................                else
....................                   datal=c-0x30;
....................                data=(datah | datal);
....................                modbus_rx.func=data;
....................                modbus_calc_crc(data);
....................                modbus_serial_state++;
....................                modbus_rx.len=0;
....................                modbus_rx.error=0;
....................             }
....................             two_characters++;
....................          }
....................          else if(modbus_serial_state == MODBUS_GETDATA)
....................          {
....................             if(c=='\r')
....................             {
....................                modbus_serial_state++;
....................                modbus_rx.len--;
....................                modbus_serial_lrc-=data;
....................             }
....................             else if(!two_characters)
....................             {
....................                if(c>=0x41)
....................                   datah=((c-0x37)<<4);
....................                else
....................                   datah=((c-0x30)<<4);
....................                two_characters++;
....................             }
....................             else
....................             {
....................                if(c>=0x41)
....................                   datal=c-0x37;
....................                else
....................                   datal=c-0x30;
....................                data=(datah | datal);
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE)
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;
....................                modbus_rx.data[modbus_rx.len]=data;
....................                modbus_rx.len++;
....................                modbus_calc_crc(data);
....................                two_characters++;
....................             }
....................          }
....................          else if(modbus_serial_state==MODBUS_STOP)
....................          {
....................             if(c=='\n')
....................             {
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1);
....................                if(modbus_serial_lrc==data)
....................                   modbus_serial_new=TRUE;
....................             }
....................             modbus_serial_state=MODBUS_START;
....................             two_characters=0;
....................          }
....................       #else
....................             
....................          if(modbus_serial_state == MODBUS_GETADDY)
02B8:  MOVF   48,F
02B9:  BTFSS  03.2
02BA:  GOTO   2CA
....................          {
....................             modbus_serial_crc.d = 0xFFFF;
02BB:  MOVLW  FF
02BC:  MOVWF  4A
02BD:  MOVWF  49
....................             modbus_rx.address = c;
02BE:  BSF    03.6
02BF:  MOVF   49,W
02C0:  BSF    03.5
02C1:  BCF    03.6
02C2:  MOVWF  20
....................             modbus_serial_state++;
02C3:  BCF    03.5
02C4:  INCF   48,F
....................             modbus_rx.len = 0;
02C5:  BSF    03.5
02C6:  CLRF   21
....................             modbus_rx.error=0;
02C7:  CLRF   23
....................          }
02C8:  GOTO   2EA
02C9:  BCF    03.5
....................          else if(modbus_serial_state == MODBUS_GETFUNC)
02CA:  DECFSZ 48,W
02CB:  GOTO   2D4
....................          {
....................             modbus_rx.func = c;
02CC:  BSF    03.6
02CD:  MOVF   49,W
02CE:  BSF    03.5
02CF:  BCF    03.6
02D0:  MOVWF  22
....................             modbus_serial_state++;
02D1:  BCF    03.5
02D2:  INCF   48,F
....................          }
02D3:  GOTO   2EB
....................          else if(modbus_serial_state == MODBUS_GETDATA)
02D4:  MOVF   48,W
02D5:  SUBLW  02
02D6:  BTFSS  03.2
02D7:  GOTO   2EB
....................          {
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;}
02D8:  BSF    03.5
02D9:  MOVF   21,W
02DA:  SUBLW  3F
02DB:  BTFSC  03.0
02DC:  GOTO   2DF
02DD:  MOVLW  3F
02DE:  MOVWF  21
....................             modbus_rx.data[modbus_rx.len]=c;
02DF:  MOVLW  A4
02E0:  ADDWF  21,W
02E1:  MOVWF  04
02E2:  BCF    03.7
02E3:  BCF    03.5
02E4:  BSF    03.6
02E5:  MOVF   49,W
02E6:  MOVWF  00
....................             modbus_rx.len++;
02E7:  BSF    03.5
02E8:  BCF    03.6
02E9:  INCF   21,F
02EA:  BCF    03.5
....................          }
....................    
....................          modbus_calc_crc(c);
02EB:  BSF    03.6
02EC:  MOVF   49,W
02ED:  MOVWF  4A
02EE:  BCF    03.6
02EF:  CALL   29F
....................          modbus_enable_timeout(TRUE);
02F0:  MOVLW  01
02F1:  BSF    03.6
02F2:  MOVWF  4A
02F3:  BCF    03.6
02F4:  CALL   265
....................       #endif
....................    }
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
....................    #endif
02F5:  BCF    0C.5
02F6:  BCF    0A.3
02F7:  BCF    0A.4
02F8:  GOTO   023
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(int8 to, int8 func)
.................... {
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII)
....................       modbus_serial_lrc=0;
....................    #else
....................       modbus_serial_crc.d=0xFFFF;
*
0E99:  MOVLW  FF
0E9A:  MOVWF  4A
0E9B:  MOVWF  49
....................    #endif
....................    modbus_serial_new=FALSE;
0E9C:  BCF    47.0
.................... 
....................    RCV_OFF();
0E9D:  BSF    03.5
0E9E:  BCF    0C.5
....................    
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
0E9F:  BCF    03.5
0EA0:  BCF    4B.5
0EA1:  MOVF   4B,W
0EA2:  BSF    03.5
0EA3:  MOVWF  07
0EA4:  BCF    03.5
0EA5:  BSF    07.5
.................... #endif
.................... 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU)
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
0EA6:  MOVLW  02
0EA7:  BSF    03.6
0EA8:  MOVWF  3F
0EA9:  MOVLW  B5
0EAA:  MOVWF  40
0EAB:  BCF    0A.3
0EAC:  BCF    03.6
0EAD:  CALL   34A
0EAE:  BSF    0A.3
0EAF:  BSF    03.6
0EB0:  DECFSZ 3F,F
0EB1:  GOTO   6A9
....................    #else
....................       fputc(':',MODBUS_SERIAL);
....................    #endif
.................... 
....................    modbus_serial_putc(to);
0EB2:  MOVF   3D,W
0EB3:  MOVWF  3F
0EB4:  BCF    03.6
0EB5:  CALL   681
....................    modbus_serial_putc(func);
0EB6:  BSF    03.6
0EB7:  MOVF   3E,W
0EB8:  MOVWF  3F
0EB9:  BCF    03.6
0EBA:  CALL   681
0EBB:  RETURN
.................... }
.................... 
.................... void modbus_serial_send_stop()
.................... {
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................       int8 i;
....................       
....................       for(i=0;i<8;i++)
....................       {
....................          if(bit_test(modbus_serial_lrc,i))
....................             bit_clear(modbus_serial_lrc,i);
....................          else
....................             bit_set(modbus_serial_lrc,i);
....................       }
....................       modbus_serial_lrc++;
....................       
....................       modbus_serial_putc(modbus_serial_lrc);
....................       fputc('\r',MODBUS_SERIAL);
....................       fputc('\n',MODBUS_SERIAL);
....................    #else
....................       int8 crc_low, crc_high;
....................    
....................       crc_high=modbus_serial_crc.b[1];
0EBC:  MOVF   4A,W
0EBD:  BSF    03.6
0EBE:  MOVWF  3E
....................       crc_low=modbus_serial_crc.b[0];
0EBF:  BCF    03.6
0EC0:  MOVF   49,W
0EC1:  BSF    03.6
0EC2:  MOVWF  3D
....................    
....................       modbus_serial_putc(crc_high);
0EC3:  MOVF   3E,W
0EC4:  MOVWF  3F
0EC5:  BCF    03.6
0EC6:  CALL   681
....................       modbus_serial_putc(crc_low);
0EC7:  BSF    03.6
0EC8:  MOVF   3D,W
0EC9:  MOVWF  3F
0ECA:  BCF    03.6
0ECB:  CALL   681
....................    #endif
....................    
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
0ECC:  BSF    03.5
0ECD:  BTFSS  18.1
0ECE:  GOTO   6CD
.................... #endif
....................    
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
0ECF:  MOVLW  02
0ED0:  BCF    03.5
0ED1:  BSF    03.6
0ED2:  MOVWF  3F
0ED3:  MOVLW  B5
0ED4:  MOVWF  40
0ED5:  BCF    0A.3
0ED6:  BCF    03.6
0ED7:  CALL   34A
0ED8:  BSF    0A.3
0ED9:  BSF    03.6
0EDA:  DECFSZ 3F,F
0EDB:  GOTO   6D3
....................    #endif
.................... 
....................    RCV_ON();
0EDC:  BCF    0A.3
0EDD:  BCF    03.6
0EDE:  CALL   7A5
0EDF:  BSF    0A.3
.................... 
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
0EE0:  BCF    4B.5
0EE1:  MOVF   4B,W
0EE2:  BSF    03.5
0EE3:  MOVWF  07
0EE4:  BCF    03.5
0EE5:  BCF    07.5
.................... #endif
.................... 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................       modbus_serial_lrc=0;
....................    #else
....................       modbus_serial_crc.d=0xFFFF;
0EE6:  MOVLW  FF
0EE7:  MOVWF  4A
0EE8:  MOVWF  49
....................    #endif
0EE9:  RETURN
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    if(!modbus_serial_new)
*
0E6D:  BTFSC  47.0
0E6E:  GOTO   673
....................       return FALSE;
0E6F:  MOVLW  00
0E70:  MOVWF  78
0E71:  GOTO   67E
0E72:  GOTO   67B
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
0E73:  BSF    03.5
0E74:  BTFSS  22.7
0E75:  GOTO   67A
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
0E76:  MOVF   24,W
0E77:  MOVWF  23
....................       modbus_rx.len = 1;
0E78:  MOVLW  01
0E79:  MOVWF  21
0E7A:  BCF    03.5
....................    }
....................    modbus_serial_new=FALSE;
0E7B:  BCF    47.0
....................    return TRUE;
0E7C:  MOVLW  01
0E7D:  MOVWF  78
0E7E:  BSF    0A.3
0E7F:  BSF    0A.4
0E80:  GOTO   591 (RETURN)
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... /*MODBUS Master Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
....................       
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(int8 address, int16 start_address, int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(int8 address, int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    if(on)
....................        modbus_serial_putc(0xFF);
....................    else
....................        modbus_serial_putc(0x00);
....................    
....................    modbus_serial_putc(0x00);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(int8 address, int16 reg_address, int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
....................    
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(int8 address, int16 start_address, int16 quantity,
....................                            int8 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = (int8)((quantity/8));
....................    
....................    if(quantity%8)
....................       count++;      
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(int8 address, int16 start_address, int16 quantity,
....................                            int16 *values)
.................... {
....................    int8 i,count;
....................    
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
....................    
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(int8 address, int8 byte_count, 
....................                             modbus_read_sub_request *request)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(int8 address, int8 byte_count, 
....................                             modbus_write_sub_request *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(int8 address, int16 read_start,
....................                                     int16 read_quantity, int16 write_start,
....................                                     int16 write_quantity,
....................                                     int16 *write_registers_value)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(int8 address, int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... /*MODBUS Slave Functions*/
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    int8 record_length;
....................    int8 reference_type;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    int8 reference_type;
....................    int16 file_number;
....................    int16 record_number;
....................    int16 record_length;
....................    int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(int8 address, int8 byte_count, int8* coil_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(int8 address, int8 byte_count, 
....................                                     int8 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(int8 address, int8 byte_count, 
....................                                         int16 *reg_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
1DED:  MOVF   37,W
1DEE:  MOVWF  3D
1DEF:  MOVLW  03
1DF0:  MOVWF  3E
1DF1:  BCF    0A.4
1DF2:  BCF    03.6
1DF3:  CALL   699
1DF4:  BSF    0A.4
.................... 
....................    modbus_serial_putc(byte_count);
1DF5:  BSF    03.6
1DF6:  MOVF   38,W
1DF7:  MOVWF  3F
1DF8:  BCF    0A.4
1DF9:  BCF    03.6
1DFA:  CALL   681
1DFB:  BSF    0A.4
.................... 
....................    for(i=0; i < byte_count; i+=2)
1DFC:  BSF    03.6
1DFD:  CLRF   3B
1DFE:  MOVF   38,W
1DFF:  SUBWF  3B,W
1E00:  BTFSC  03.0
1E01:  GOTO   632
....................    {
....................       modbus_serial_putc(make8(*reg_data,1));
1E02:  MOVF   3A,W
1E03:  MOVWF  7A
1E04:  MOVF   39,W
1E05:  MOVWF  04
1E06:  BCF    03.7
1E07:  BTFSC  3A.0
1E08:  BSF    03.7
1E09:  INCF   04,F
1E0A:  MOVF   00,W
1E0B:  MOVWF  3D
1E0C:  DECF   04,F
1E0D:  MOVF   00,W
1E0E:  MOVWF  3C
1E0F:  MOVF   3D,W
1E10:  MOVWF  3E
1E11:  MOVWF  3F
1E12:  BCF    0A.4
1E13:  BCF    03.6
1E14:  CALL   681
1E15:  BSF    0A.4
....................       modbus_serial_putc(make8(*reg_data,0));
1E16:  BSF    03.6
1E17:  MOVF   3A,W
1E18:  MOVWF  7A
1E19:  MOVF   39,W
1E1A:  MOVWF  04
1E1B:  BCF    03.7
1E1C:  BTFSC  3A.0
1E1D:  BSF    03.7
1E1E:  INCF   04,F
1E1F:  MOVF   00,W
1E20:  MOVWF  3D
1E21:  DECF   04,F
1E22:  MOVF   00,W
1E23:  MOVWF  3C
1E24:  MOVWF  3E
1E25:  MOVWF  3F
1E26:  BCF    0A.4
1E27:  BCF    03.6
1E28:  CALL   681
1E29:  BSF    0A.4
....................       reg_data++;
1E2A:  MOVLW  02
1E2B:  BSF    03.6
1E2C:  ADDWF  39,F
1E2D:  BTFSC  03.0
1E2E:  INCF   3A,F
1E2F:  MOVLW  02
1E30:  ADDWF  3B,F
1E31:  GOTO   5FE
....................    }
.................... 
....................    modbus_serial_send_stop();
1E32:  BCF    0A.4
1E33:  BCF    03.6
1E34:  CALL   6BC
1E35:  BSF    0A.4
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(int8 address, int8 byte_count, 
....................                                         int16 *input_data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
*
1E51:  MOVF   37,W
1E52:  MOVWF  3D
1E53:  MOVLW  04
1E54:  MOVWF  3E
1E55:  BCF    0A.4
1E56:  BCF    03.6
1E57:  CALL   699
1E58:  BSF    0A.4
.................... 
....................    modbus_serial_putc(byte_count);
1E59:  BSF    03.6
1E5A:  MOVF   38,W
1E5B:  MOVWF  3F
1E5C:  BCF    0A.4
1E5D:  BCF    03.6
1E5E:  CALL   681
1E5F:  BSF    0A.4
.................... 
....................    for(i=0; i < byte_count; i+=2)
1E60:  BSF    03.6
1E61:  CLRF   3B
1E62:  MOVF   38,W
1E63:  SUBWF  3B,W
1E64:  BTFSC  03.0
1E65:  GOTO   696
....................    {
....................       modbus_serial_putc(make8(*input_data,1));
1E66:  MOVF   3A,W
1E67:  MOVWF  7A
1E68:  MOVF   39,W
1E69:  MOVWF  04
1E6A:  BCF    03.7
1E6B:  BTFSC  3A.0
1E6C:  BSF    03.7
1E6D:  INCF   04,F
1E6E:  MOVF   00,W
1E6F:  MOVWF  3D
1E70:  DECF   04,F
1E71:  MOVF   00,W
1E72:  MOVWF  3C
1E73:  MOVF   3D,W
1E74:  MOVWF  3E
1E75:  MOVWF  3F
1E76:  BCF    0A.4
1E77:  BCF    03.6
1E78:  CALL   681
1E79:  BSF    0A.4
....................       modbus_serial_putc(make8(*input_data,0));
1E7A:  BSF    03.6
1E7B:  MOVF   3A,W
1E7C:  MOVWF  7A
1E7D:  MOVF   39,W
1E7E:  MOVWF  04
1E7F:  BCF    03.7
1E80:  BTFSC  3A.0
1E81:  BSF    03.7
1E82:  INCF   04,F
1E83:  MOVF   00,W
1E84:  MOVWF  3D
1E85:  DECF   04,F
1E86:  MOVF   00,W
1E87:  MOVWF  3C
1E88:  MOVWF  3E
1E89:  MOVWF  3F
1E8A:  BCF    0A.4
1E8B:  BCF    03.6
1E8C:  CALL   681
1E8D:  BSF    0A.4
....................       input_data++;
1E8E:  MOVLW  02
1E8F:  BSF    03.6
1E90:  ADDWF  39,F
1E91:  BTFSC  03.0
1E92:  INCF   3A,F
1E93:  MOVLW  02
1E94:  ADDWF  3B,F
1E95:  GOTO   662
....................    }
.................... 
....................    modbus_serial_send_stop();
1E96:  BCF    0A.4
1E97:  BCF    03.6
1E98:  CALL   6BC
1E99:  BSF    0A.4
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(int8 address, int16 output_address, 
....................                                     int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(int8 address, int16 reg_address, 
....................                                         int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(int8 address, int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(int8 address, int16 sub_func, int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(int8 address, int16 status, 
....................                                         int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(int8 address, int16 status,
....................                                     int16 event_count, int16 message_count, 
....................                                     int8 *events, int8 events_len)
.................... {
....................    int8 i;
....................     
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(int8 address, int16 start_address, 
....................                                         int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(int8 address, int16 start_address, 
....................                                             int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
*
1F23:  MOVF   38,W
1F24:  MOVWF  3D
1F25:  MOVLW  10
1F26:  MOVWF  3E
1F27:  BCF    0A.4
1F28:  BCF    03.6
1F29:  CALL   699
1F2A:  BSF    0A.4
.................... 
....................    modbus_serial_putc(make8(start_address,1));
1F2B:  BSF    03.6
1F2C:  MOVF   3A,W
1F2D:  MOVWF  3D
1F2E:  MOVWF  3F
1F2F:  BCF    0A.4
1F30:  BCF    03.6
1F31:  CALL   681
1F32:  BSF    0A.4
....................    modbus_serial_putc(make8(start_address,0));
1F33:  BSF    03.6
1F34:  MOVF   39,W
1F35:  MOVWF  3D
1F36:  MOVWF  3F
1F37:  BCF    0A.4
1F38:  BCF    03.6
1F39:  CALL   681
1F3A:  BSF    0A.4
.................... 
....................    modbus_serial_putc(make8(quantity,1));
1F3B:  BSF    03.6
1F3C:  MOVF   3C,W
1F3D:  MOVWF  3D
1F3E:  MOVWF  3F
1F3F:  BCF    0A.4
1F40:  BCF    03.6
1F41:  CALL   681
1F42:  BSF    0A.4
....................    modbus_serial_putc(make8(quantity,0));
1F43:  BSF    03.6
1F44:  MOVF   3B,W
1F45:  MOVWF  3D
1F46:  MOVWF  3F
1F47:  BCF    0A.4
1F48:  BCF    03.6
1F49:  CALL   681
1F4A:  BSF    0A.4
.................... 
....................    modbus_serial_send_stop();
1F4B:  BCF    0A.4
1F4C:  CALL   6BC
1F4D:  BSF    0A.4
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(int8 address, int8 slave_id, int1 run_status,
....................                               int8 *data, int8 data_len)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(int8 address, int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(int8 address, int16 reference_address,
....................                            int16 AND_mask, int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(int8 address, int8 data_len, 
....................                                                 int16 *data)
.................... {
....................    int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(int8 address, int16 FIFO_len, int16 *data)
.................... {
....................    int8 i;
....................    int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... void modbus_exception_rsp(int8 address, int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
*
0EEA:  BSF    03.6
0EEB:  MOVF   35,W
0EEC:  IORLW  80
0EED:  MOVWF  38
0EEE:  MOVF   36,W
0EEF:  MOVWF  39
0EF0:  MOVF   34,W
0EF1:  MOVWF  3D
0EF2:  MOVF   38,W
0EF3:  MOVWF  3E
0EF4:  BCF    03.6
0EF5:  CALL   699
....................    modbus_serial_putc(error);
0EF6:  BSF    03.6
0EF7:  MOVF   37,W
0EF8:  MOVWF  3F
0EF9:  BCF    03.6
0EFA:  CALL   681
....................    modbus_serial_send_stop();
0EFB:  CALL   6BC
0EFC:  RETURN
.................... }
.................... 
.................... #endif
.................... 
.................... //                                                                                                                               //
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //                                            KHAI BAO BIEN TOAN CUC                                                             //
....................    signed int16 big_hold_regs[7];
....................    int16 big_input_regs[17];   
....................    int8 regis_num = 7;
....................    
....................    int32 big_coils = 0x00000000;
....................    int32 coil_data_reciev = 0x00000000;
....................    int32 big_inputs = 0x0000006;//Chua code
....................    
.................... //#separate
.................... void modbus_process()
.................... {
....................    //while(!modbus_kbhit());
....................    
....................    delay_us(50);
*
1D95:  MOVLW  53
1D96:  MOVWF  77
1D97:  DECFSZ 77,F
1D98:  GOTO   597
....................    
....................    //check address against our address, 0 is broadcast
....................    if((modbus_rx.address == MODBUS_ADDRESS))// || modbus_rx.address == 0)
1D99:  BSF    03.5
1D9A:  MOVF   20,W
1D9B:  SUBLW  32
1D9C:  BTFSS  03.2
1D9D:  GOTO   760
....................    {
....................       switch(modbus_rx.func)
1D9E:  MOVF   22,W
1D9F:  XORLW  03
1DA0:  BCF    03.5
1DA1:  BTFSC  03.2
1DA2:  GOTO   5AA
1DA3:  XORLW  07
1DA4:  BTFSC  03.2
1DA5:  GOTO   5AA
1DA6:  XORLW  14
1DA7:  BTFSC  03.2
1DA8:  GOTO   69B
1DA9:  GOTO   74F
....................       {
....................          case FUNC_READ_HOLDING_REGISTERS:
....................          case FUNC_READ_INPUT_REGISTERS:
....................             if(modbus_rx.data[0] || modbus_rx.data[2] ||
....................                modbus_rx.data[1] >= regis_num || modbus_rx.data[3]+modbus_rx.data[1] > regis_num)     //regis_num: so thanh ghi Hold (Input) khai bao ben tren
1DAA:  BSF    03.5
1DAB:  MOVF   24,F
1DAC:  BTFSS  03.2
1DAD:  GOTO   5BE
1DAE:  MOVF   26,F
1DAF:  BTFSS  03.2
1DB0:  GOTO   5BE
1DB1:  BCF    03.5
1DB2:  MOVF   5A,W
1DB3:  BSF    03.5
1DB4:  SUBWF  25,W
1DB5:  BTFSC  03.0
1DB6:  GOTO   5BE
1DB7:  MOVF   25,W
1DB8:  ADDWF  27,W
1DB9:  BCF    03.5
1DBA:  SUBWF  5A,W
1DBB:  BTFSC  03.0
1DBC:  GOTO   5D0
1DBD:  BSF    03.5
....................                modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
1DBE:  MOVLW  32
1DBF:  BCF    03.5
1DC0:  BSF    03.6
1DC1:  MOVWF  34
1DC2:  CLRF   36
1DC3:  BSF    03.5
1DC4:  BCF    03.6
1DC5:  MOVF   22,W
1DC6:  BCF    03.5
1DC7:  BSF    03.6
1DC8:  MOVWF  35
1DC9:  MOVLW  02
1DCA:  MOVWF  37
1DCB:  BCF    0A.4
1DCC:  BCF    03.6
1DCD:  CALL   6EA
1DCE:  BSF    0A.4
1DCF:  GOTO   69A
....................             else
....................             {
....................                if(modbus_rx.func == FUNC_READ_HOLDING_REGISTERS)
1DD0:  BSF    03.5
1DD1:  MOVF   22,W
1DD2:  SUBLW  03
1DD3:  BTFSS  03.2
1DD4:  GOTO   638
....................                   modbus_read_holding_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),big_hold_regs+modbus_rx.data[1]);
1DD5:  BCF    03.0
1DD6:  RLF    27,W
1DD7:  BCF    03.5
1DD8:  BSF    03.6
1DD9:  MOVWF  34
1DDA:  BCF    03.0
1DDB:  BSF    03.5
1DDC:  BCF    03.6
1DDD:  RLF    25,W
1DDE:  ADDLW  4C
1DDF:  BCF    03.5
1DE0:  BSF    03.6
1DE1:  MOVWF  35
1DE2:  CLRF   36
1DE3:  BTFSC  03.0
1DE4:  INCF   36,F
1DE5:  MOVLW  32
1DE6:  MOVWF  37
1DE7:  MOVF   34,W
1DE8:  MOVWF  38
1DE9:  MOVF   36,W
1DEA:  MOVWF  3A
1DEB:  MOVF   35,W
1DEC:  MOVWF  39
*
1E36:  GOTO   69A
1E37:  BSF    03.5
....................                else
....................                   modbus_read_input_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),big_input_regs+modbus_rx.data[1]);
1E38:  BCF    03.0
1E39:  RLF    27,W
1E3A:  BCF    03.5
1E3B:  BSF    03.6
1E3C:  MOVWF  34
1E3D:  BCF    03.0
1E3E:  BSF    03.5
1E3F:  BCF    03.6
1E40:  RLF    25,W
1E41:  ADDLW  10
1E42:  BCF    03.5
1E43:  BSF    03.6
1E44:  MOVWF  35
1E45:  MOVLW  01
1E46:  MOVWF  36
1E47:  BTFSC  03.0
1E48:  INCF   36,F
1E49:  MOVLW  32
1E4A:  MOVWF  37
1E4B:  MOVF   34,W
1E4C:  MOVWF  38
1E4D:  MOVF   36,W
1E4E:  MOVWF  3A
1E4F:  MOVF   35,W
1E50:  MOVWF  39
....................                
....................             }
....................             break;
*
1E9A:  GOTO   75F
....................          /*case FUNC_WRITE_SINGLE_REGISTER:
....................             if(modbus_rx.data[0] || modbus_rx.data[1] >= regis_num)
....................                modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
....................             else
....................             {
....................                //the registers are stored in little endian format
....................                big_hold_regs[modbus_rx.data[1]] = make16(modbus_rx.data[2],modbus_rx.data[3]);//lay 2 byte du lieu ghi vao thanh ghi "hold_regs"
....................                
....................                //Response lai khung du lieu vua nhan tu PC (Du lieu request)
....................                modbus_write_single_register_rsp(MODBUS_ADDRESS,
....................                             make16(modbus_rx.data[0],modbus_rx.data[1]),
....................                             make16(modbus_rx.data[2],modbus_rx.data[3]));
....................             }
....................             break;*/
....................          case FUNC_WRITE_MULTIPLE_REGISTERS:
....................             if(modbus_rx.data[0] || modbus_rx.data[2] ||
....................                modbus_rx.data[1] >= regis_num || modbus_rx.data[3]+modbus_rx.data[1] > regis_num)
1E9B:  BSF    03.5
1E9C:  MOVF   24,F
1E9D:  BTFSS  03.2
1E9E:  GOTO   6AF
1E9F:  MOVF   26,F
1EA0:  BTFSS  03.2
1EA1:  GOTO   6AF
1EA2:  BCF    03.5
1EA3:  MOVF   5A,W
1EA4:  BSF    03.5
1EA5:  SUBWF  25,W
1EA6:  BTFSC  03.0
1EA7:  GOTO   6AF
1EA8:  MOVF   25,W
1EA9:  ADDWF  27,W
1EAA:  BCF    03.5
1EAB:  SUBWF  5A,W
1EAC:  BTFSC  03.0
1EAD:  GOTO   6C1
1EAE:  BSF    03.5
....................                modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
1EAF:  MOVLW  32
1EB0:  BCF    03.5
1EB1:  BSF    03.6
1EB2:  MOVWF  34
1EB3:  CLRF   36
1EB4:  BSF    03.5
1EB5:  BCF    03.6
1EB6:  MOVF   22,W
1EB7:  BCF    03.5
1EB8:  BSF    03.6
1EB9:  MOVWF  35
1EBA:  MOVLW  02
1EBB:  MOVWF  37
1EBC:  BCF    0A.4
1EBD:  BCF    03.6
1EBE:  CALL   6EA
1EBF:  BSF    0A.4
1EC0:  GOTO   74E
....................             else
....................             {
....................                int i,j;
.................... 
....................                for(i=0,j=5; i < modbus_rx.data[4]/2; ++i,j+=2)
1EC1:  BSF    03.6
1EC2:  CLRF   32
1EC3:  MOVLW  05
1EC4:  MOVWF  33
1EC5:  BCF    03.0
1EC6:  BSF    03.5
1EC7:  BCF    03.6
1EC8:  RRF    28,W
1EC9:  BCF    03.5
1ECA:  BSF    03.6
1ECB:  SUBWF  32,W
1ECC:  BTFSC  03.0
1ECD:  GOTO   701
....................                   big_hold_regs[(i+modbus_rx.data[1])] = make16(modbus_rx.data[j],modbus_rx.data[j+1]);
1ECE:  BSF    03.5
1ECF:  BCF    03.6
1ED0:  MOVF   25,W
1ED1:  BCF    03.5
1ED2:  BSF    03.6
1ED3:  ADDWF  32,W
1ED4:  MOVWF  77
1ED5:  BCF    03.0
1ED6:  RLF    77,F
1ED7:  MOVF   77,W
1ED8:  ADDLW  4C
1ED9:  MOVWF  78
1EDA:  CLRF   7A
1EDB:  BTFSC  03.0
1EDC:  INCF   7A,F
1EDD:  MOVF   78,W
1EDE:  MOVWF  34
1EDF:  MOVF   7A,W
1EE0:  MOVWF  35
1EE1:  MOVLW  A4
1EE2:  ADDWF  33,W
1EE3:  MOVWF  04
1EE4:  BCF    03.7
1EE5:  MOVF   00,W
1EE6:  MOVWF  36
1EE7:  MOVLW  01
1EE8:  ADDWF  33,W
1EE9:  ADDLW  A4
1EEA:  MOVWF  04
1EEB:  BCF    03.7
1EEC:  MOVF   00,W
1EED:  MOVWF  37
1EEE:  MOVF   36,W
1EEF:  MOVWF  39
1EF0:  MOVF   37,W
1EF1:  MOVWF  38
1EF2:  MOVF   34,W
1EF3:  MOVWF  04
1EF4:  BCF    03.7
1EF5:  BTFSC  35.0
1EF6:  BSF    03.7
1EF7:  INCF   04,F
1EF8:  MOVF   39,W
1EF9:  MOVWF  00
1EFA:  DECF   04,F
1EFB:  MOVF   38,W
1EFC:  MOVWF  00
1EFD:  INCF   32,F
1EFE:  MOVLW  02
1EFF:  ADDWF  33,F
1F00:  GOTO   6C5
.................... 
....................                modbus_write_multiple_registers_rsp(MODBUS_ADDRESS,
....................                               make16(modbus_rx.data[0],modbus_rx.data[1]),
....................                               make16(modbus_rx.data[2],modbus_rx.data[3]));            
1F01:  BSF    03.5
1F02:  BCF    03.6
1F03:  MOVF   24,W
1F04:  BCF    03.5
1F05:  BSF    03.6
1F06:  MOVWF  35
1F07:  BSF    03.5
1F08:  BCF    03.6
1F09:  MOVF   25,W
1F0A:  BCF    03.5
1F0B:  BSF    03.6
1F0C:  MOVWF  34
1F0D:  BSF    03.5
1F0E:  BCF    03.6
1F0F:  MOVF   26,W
1F10:  BCF    03.5
1F11:  BSF    03.6
1F12:  MOVWF  37
1F13:  BSF    03.5
1F14:  BCF    03.6
1F15:  MOVF   27,W
1F16:  BCF    03.5
1F17:  BSF    03.6
1F18:  MOVWF  36
1F19:  MOVLW  32
1F1A:  MOVWF  38
1F1B:  MOVF   35,W
1F1C:  MOVWF  3A
1F1D:  MOVF   34,W
1F1E:  MOVWF  39
1F1F:  MOVF   37,W
1F20:  MOVWF  3C
1F21:  MOVF   36,W
1F22:  MOVWF  3B
....................             }
....................             break;           
*
1F4E:  GOTO   75F
....................          default:    //We don't support the function, so return exception
....................             modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_FUNCTION);
1F4F:  MOVLW  32
1F50:  BSF    03.6
1F51:  MOVWF  34
1F52:  CLRF   36
1F53:  BSF    03.5
1F54:  BCF    03.6
1F55:  MOVF   22,W
1F56:  BCF    03.5
1F57:  BSF    03.6
1F58:  MOVWF  35
1F59:  MOVLW  01
1F5A:  MOVWF  37
1F5B:  BCF    0A.4
1F5C:  BCF    03.6
1F5D:  CALL   6EA
1F5E:  BSF    0A.4
1F5F:  BSF    03.5
....................       }
....................    }
.................... }
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #include <Ds18d20.c>
.................... 
.................... #define DQ pin_E0
.................... //----------------------------------------------------------------
.................... #separate
.................... init_1wire(){
....................    int a;
.................... 
....................    output_low(DQ);
*
035B:  BSF    03.5
035C:  BCF    09.0
035D:  BCF    03.5
035E:  BCF    09.0
....................    delay_us(480);
035F:  MOVLW  02
0360:  BSF    03.6
0361:  MOVWF  33
0362:  MOVLW  EF
0363:  MOVWF  40
0364:  BCF    03.6
0365:  CALL   34A
0366:  BSF    03.6
0367:  DECFSZ 33,F
0368:  GOTO   362
....................    output_float(DQ);
0369:  BSF    03.5
036A:  BCF    03.6
036B:  BSF    09.0
....................    delay_us(72);
036C:  MOVLW  77
036D:  MOVWF  77
036E:  DECFSZ 77,F
036F:  GOTO   36E
0370:  GOTO   371
....................    a=!input(DQ);
0371:  BSF    09.0
0372:  BCF    03.5
0373:  BSF    03.6
0374:  CLRF   32
0375:  BCF    03.6
0376:  BTFSC  09.0
0377:  GOTO   37B
0378:  BSF    03.6
0379:  INCF   32,F
037A:  BCF    03.6
....................    delay_us(425);
037B:  MOVLW  05
037C:  BSF    03.6
037D:  MOVWF  33
037E:  MOVLW  54
037F:  MOVWF  40
0380:  BCF    03.6
0381:  CALL   34A
0382:  BSF    03.6
0383:  DECFSZ 33,F
0384:  GOTO   37E
....................    if(a)
0385:  MOVF   32,F
0386:  BTFSC  03.2
0387:  GOTO   38C
....................       return(1);
0388:  MOVLW  01
0389:  MOVWF  78
038A:  GOTO   38E
038B:  GOTO   38E
....................    else
....................       return(0);
038C:  MOVLW  00
038D:  MOVWF  78
038E:  BCF    03.6
038F:  RETURN
.................... }
.................... 
.................... //-------------------------read byte------------------------------
.................... #separate
.................... byte read_1wire(){
....................    byte a,data;
....................    for(a=0;a<8;a++){
*
03C2:  BSF    03.6
03C3:  CLRF   34
03C4:  MOVF   34,W
03C5:  SUBLW  07
03C6:  BTFSS  03.0
03C7:  GOTO   3E7
....................       output_low(DQ);
03C8:  BSF    03.5
03C9:  BCF    03.6
03CA:  BCF    09.0
03CB:  BCF    03.5
03CC:  BCF    09.0
....................       delay_us(1);
03CD:  GOTO   3CE
03CE:  GOTO   3CF
03CF:  NOP
....................       output_float(DQ);
03D0:  BSF    03.5
03D1:  BSF    09.0
....................       delay_us(15);
03D2:  MOVLW  18
03D3:  MOVWF  77
03D4:  DECFSZ 77,F
03D5:  GOTO   3D4
03D6:  GOTO   3D7
....................       shift_right(&data,1,input(DQ));
03D7:  BSF    09.0
03D8:  BCF    03.5
03D9:  BTFSC  09.0
03DA:  GOTO   3DD
03DB:  BCF    03.0
03DC:  GOTO   3DE
03DD:  BSF    03.0
03DE:  BSF    03.6
03DF:  RRF    35,F
....................       delay_us(120);
03E0:  MOVLW  C7
03E1:  MOVWF  77
03E2:  DECFSZ 77,F
03E3:  GOTO   3E2
03E4:  GOTO   3E5
03E5:  INCF   34,F
03E6:  GOTO   3C4
....................    }
....................    return(data);
03E7:  MOVF   35,W
03E8:  MOVWF  78
03E9:  BCF    03.6
03EA:  BSF    0A.3
03EB:  BCF    0A.4
03EC:  GOTO   037 (RETURN)
.................... }   
.................... //--------------------------write byte----------------------------
.................... #separate
.................... byte write_1wire(byte data)
.................... {
....................    byte a;
.................... 
....................    for(a=0;a<8;a++)
*
0390:  BSF    03.6
0391:  CLRF   33
0392:  MOVF   33,W
0393:  SUBLW  07
0394:  BTFSS  03.0
0395:  GOTO   3BA
....................    {
....................       output_low(DQ);
0396:  BSF    03.5
0397:  BCF    03.6
0398:  BCF    09.0
0399:  BCF    03.5
039A:  BCF    09.0
....................       delay_us(1);
039B:  GOTO   39C
039C:  GOTO   39D
039D:  NOP
....................       if(shift_right(&data,1,0))
039E:  BCF    03.0
039F:  BSF    03.6
03A0:  RRF    32,F
03A1:  BTFSS  03.0
03A2:  GOTO   3AA
....................          output_high(DQ);
03A3:  BSF    03.5
03A4:  BCF    03.6
03A5:  BCF    09.0
03A6:  BCF    03.5
03A7:  BSF    09.0
03A8:  GOTO   3AF
03A9:  BSF    03.6
....................       else
....................          output_low(DQ);
03AA:  BSF    03.5
03AB:  BCF    03.6
03AC:  BCF    09.0
03AD:  BCF    03.5
03AE:  BCF    09.0
....................          
....................       delay_us(104);
03AF:  MOVLW  AD
03B0:  MOVWF  77
03B1:  DECFSZ 77,F
03B2:  GOTO   3B1
....................       output_high(DQ);
03B3:  BSF    03.5
03B4:  BCF    09.0
03B5:  BCF    03.5
03B6:  BSF    09.0
03B7:  BSF    03.6
03B8:  INCF   33,F
03B9:  GOTO   392
....................    }
....................    delay_us(104);
03BA:  MOVLW  AD
03BB:  MOVWF  77
03BC:  DECFSZ 77,F
03BD:  GOTO   3BC
....................    return(1);
03BE:  MOVLW  01
03BF:  MOVWF  78
03C0:  BCF    03.6
03C1:  RETURN
.................... }
.................... 
.................... byte buffer[8];
.................... int1 read_ok=0;
.................... int1 minus=0;
.................... float temp=0;//,Old_temp=0;
.................... #separate   
.................... void Get_temp()
.................... {      
....................    if(init_1wire())
*
0800:  BCF    0A.3
0801:  CALL   35B
0802:  BSF    0A.3
0803:  MOVF   78,F
0804:  BTFSC  03.2
0805:  GOTO   014
....................    {
....................       write_1wire(0xcc);                                       //skip ROM
0806:  MOVLW  CC
0807:  BSF    03.6
0808:  MOVWF  32
0809:  BCF    0A.3
080A:  BCF    03.6
080B:  CALL   390
080C:  BSF    0A.3
....................       write_1wire(0x44);                                       //convert T
080D:  MOVLW  44
080E:  BSF    03.6
080F:  MOVWF  32
0810:  BCF    0A.3
0811:  BCF    03.6
0812:  CALL   390
0813:  BSF    0A.3
....................    }
.................... 
....................    if(init_1wire())
0814:  BCF    0A.3
0815:  CALL   35B
0816:  BSF    0A.3
0817:  MOVF   78,F
0818:  BTFSC  03.2
0819:  GOTO   04A
....................    {
....................       write_1wire(0xcc);                                       //skip ROM
081A:  MOVLW  CC
081B:  BSF    03.6
081C:  MOVWF  32
081D:  BCF    0A.3
081E:  BCF    03.6
081F:  CALL   390
0820:  BSF    0A.3
....................       write_1wire(0xbe);                                       //read scratchpad
0821:  MOVLW  BE
0822:  BSF    03.6
0823:  MOVWF  32
0824:  BCF    0A.3
0825:  BCF    03.6
0826:  CALL   390
0827:  BSF    0A.3
....................       for(i=0;i<8;i++)
0828:  CLRF   28
0829:  MOVF   28,W
082A:  SUBLW  07
082B:  BTFSS  03.0
082C:  GOTO   048
....................       {
....................          buffer[i]=read_1wire();
082D:  MOVLW  67
082E:  ADDWF  28,W
082F:  BSF    03.6
0830:  MOVWF  32
0831:  CLRF   33
0832:  BTFSC  03.0
0833:  INCF   33,F
0834:  BCF    0A.3
0835:  BCF    03.6
0836:  GOTO   3C2
0837:  BSF    0A.3
0838:  BSF    03.6
0839:  MOVF   32,W
083A:  MOVWF  04
083B:  BCF    03.7
083C:  BTFSC  33.0
083D:  BSF    03.7
083E:  MOVF   78,W
083F:  MOVWF  00
....................          delay_us(10);
0840:  MOVLW  10
0841:  MOVWF  77
0842:  DECFSZ 77,F
0843:  GOTO   042
0844:  NOP
0845:  BCF    03.6
0846:  INCF   28,F
0847:  GOTO   029
....................       }
....................       read_ok=1;
0848:  BSF    47.1
....................    }
0849:  GOTO   04B
....................    else
....................    {
....................       read_ok=0;
084A:  BCF    47.1
....................    }
....................    
....................    if(read_ok)
084B:  BTFSS  47.1
084C:  GOTO   5D6
....................    {      
....................       if(buffer[1]>=16)//neu nhiet do la am dao lai buffer[1],buffer[0]
084D:  MOVF   68,W
084E:  SUBLW  0F
084F:  BTFSC  03.0
0850:  GOTO   0A2
....................       {
....................           buffer[1]=~buffer[1];
0851:  COMF   68,F
....................           buffer[0]=~buffer[0];
0852:  COMF   67,F
....................           buffer[0]=buffer[0]+1;//hieu chinh lai de hien thi cho dung
0853:  MOVLW  01
0854:  ADDWF  67,F
....................           temp=make16(buffer[1],buffer[0]);
0855:  MOVF   68,W
0856:  MOVWF  7A
0857:  MOVF   67,W
0858:  BSF    03.6
0859:  MOVWF  32
085A:  MOVF   7A,W
085B:  MOVWF  33
085C:  BCF    0A.3
085D:  BCF    03.6
085E:  CALL   3ED
085F:  BSF    0A.3
0860:  MOVF   7A,W
0861:  MOVWF  72
0862:  MOVF   79,W
0863:  MOVWF  71
0864:  MOVF   78,W
0865:  MOVWF  70
0866:  MOVF   77,W
0867:  MOVWF  6F
....................           temp= (float) temp/16.0; 
0868:  MOVF   72,W
0869:  BSF    03.6
086A:  MOVWF  39
086B:  MOVF   71,W
086C:  MOVWF  38
086D:  MOVF   70,W
086E:  MOVWF  37
086F:  BCF    03.6
0870:  MOVF   6F,W
0871:  BSF    03.6
0872:  MOVWF  36
0873:  CLRF   3D
0874:  CLRF   3C
0875:  CLRF   3B
0876:  MOVLW  83
0877:  MOVWF  3A
0878:  BCF    0A.3
0879:  BCF    03.6
087A:  CALL   40C
087B:  BSF    0A.3
087C:  MOVF   7A,W
087D:  MOVWF  72
087E:  MOVF   79,W
087F:  MOVWF  71
0880:  MOVF   78,W
0881:  MOVWF  70
0882:  MOVF   77,W
0883:  MOVWF  6F
....................           temp=temp*(-1);
0884:  MOVF   72,W
0885:  BSF    03.6
0886:  MOVWF  35
0887:  MOVF   71,W
0888:  MOVWF  34
0889:  MOVF   70,W
088A:  MOVWF  33
088B:  BCF    03.6
088C:  MOVF   6F,W
088D:  BSF    03.6
088E:  MOVWF  32
088F:  CLRF   39
0890:  CLRF   38
0891:  MOVLW  80
0892:  MOVWF  37
0893:  MOVLW  7F
0894:  MOVWF  36
0895:  BCF    0A.3
0896:  BCF    03.6
0897:  CALL   4D8
0898:  BSF    0A.3
0899:  MOVF   7A,W
089A:  MOVWF  72
089B:  MOVF   79,W
089C:  MOVWF  71
089D:  MOVF   78,W
089E:  MOVWF  70
089F:  MOVF   77,W
08A0:  MOVWF  6F
....................       }
08A1:  GOTO   0D1
....................       else
....................       {
....................           temp=make16(buffer[1],buffer[0]);
08A2:  MOVF   68,W
08A3:  MOVWF  7A
08A4:  MOVF   67,W
08A5:  BSF    03.6
08A6:  MOVWF  32
08A7:  MOVF   7A,W
08A8:  MOVWF  33
08A9:  BCF    0A.3
08AA:  BCF    03.6
08AB:  CALL   3ED
08AC:  BSF    0A.3
08AD:  MOVF   7A,W
08AE:  MOVWF  72
08AF:  MOVF   79,W
08B0:  MOVWF  71
08B1:  MOVF   78,W
08B2:  MOVWF  70
08B3:  MOVF   77,W
08B4:  MOVWF  6F
....................           temp= (float) temp/16.0;
08B5:  MOVF   72,W
08B6:  BSF    03.6
08B7:  MOVWF  39
08B8:  MOVF   71,W
08B9:  MOVWF  38
08BA:  MOVF   70,W
08BB:  MOVWF  37
08BC:  BCF    03.6
08BD:  MOVF   6F,W
08BE:  BSF    03.6
08BF:  MOVWF  36
08C0:  CLRF   3D
08C1:  CLRF   3C
08C2:  CLRF   3B
08C3:  MOVLW  83
08C4:  MOVWF  3A
08C5:  BCF    0A.3
08C6:  BCF    03.6
08C7:  CALL   40C
08C8:  BSF    0A.3
08C9:  MOVF   7A,W
08CA:  MOVWF  72
08CB:  MOVF   79,W
08CC:  MOVWF  71
08CD:  MOVF   78,W
08CE:  MOVWF  70
08CF:  MOVF   77,W
08D0:  MOVWF  6F
....................       }
....................       // Ham lay gia tri nhiet do sau hieu chinh
....................       temp=temp + 0.6 +(temp_offset/10);
08D1:  BCF    03.1
08D2:  MOVF   72,W
08D3:  BSF    03.6
08D4:  MOVWF  39
08D5:  MOVF   71,W
08D6:  MOVWF  38
08D7:  MOVF   70,W
08D8:  MOVWF  37
08D9:  BCF    03.6
08DA:  MOVF   6F,W
08DB:  BSF    03.6
08DC:  MOVWF  36
08DD:  MOVLW  9A
08DE:  MOVWF  3D
08DF:  MOVLW  99
08E0:  MOVWF  3C
08E1:  MOVLW  19
08E2:  MOVWF  3B
08E3:  MOVLW  7E
08E4:  MOVWF  3A
08E5:  BCF    0A.3
08E6:  BCF    03.6
08E7:  CALL   54F
08E8:  BSF    0A.3
08E9:  MOVF   7A,W
08EA:  BSF    03.6
08EB:  MOVWF  35
08EC:  MOVF   79,W
08ED:  MOVWF  34
08EE:  MOVF   78,W
08EF:  MOVWF  33
08F0:  MOVF   77,W
08F1:  MOVWF  32
08F2:  BCF    03.6
08F3:  MOVF   34,W
08F4:  BSF    03.6
08F5:  MOVWF  39
08F6:  BCF    03.6
08F7:  MOVF   33,W
08F8:  BSF    03.6
08F9:  MOVWF  38
08FA:  BCF    03.6
08FB:  MOVF   32,W
08FC:  BSF    03.6
08FD:  MOVWF  37
08FE:  BCF    03.6
08FF:  MOVF   31,W
0900:  BSF    03.6
0901:  MOVWF  36
0902:  CLRF   3D
0903:  CLRF   3C
0904:  MOVLW  20
0905:  MOVWF  3B
0906:  MOVLW  82
0907:  MOVWF  3A
0908:  BCF    0A.3
0909:  BCF    03.6
090A:  CALL   40C
090B:  BSF    0A.3
090C:  BCF    03.1
090D:  BSF    03.6
090E:  MOVF   35,W
090F:  MOVWF  39
0910:  MOVF   34,W
0911:  MOVWF  38
0912:  MOVF   33,W
0913:  MOVWF  37
0914:  MOVF   32,W
0915:  MOVWF  36
0916:  MOVF   7A,W
0917:  MOVWF  3D
0918:  MOVF   79,W
0919:  MOVWF  3C
091A:  MOVF   78,W
091B:  MOVWF  3B
091C:  MOVF   77,W
091D:  MOVWF  3A
091E:  BCF    0A.3
091F:  BCF    03.6
0920:  CALL   54F
0921:  BSF    0A.3
0922:  MOVF   7A,W
0923:  MOVWF  72
0924:  MOVF   79,W
0925:  MOVWF  71
0926:  MOVF   78,W
0927:  MOVWF  70
0928:  MOVF   77,W
0929:  MOVWF  6F
....................       /*if((( temp - Old_temp)>=3)||(( Old_temp - Temp)>=3))
....................       {
....................          temp =Old_temp;
....................       }
....................       else
....................       {
....................          Old_temp=temp;
....................       }*/
....................       if(temp>=0)
092A:  BSF    03.6
092B:  CLRF   39
092C:  CLRF   38
092D:  CLRF   37
092E:  CLRF   36
092F:  MOVF   72,W
0930:  MOVWF  3D
0931:  MOVF   71,W
0932:  MOVWF  3C
0933:  MOVF   70,W
0934:  MOVWF  3B
0935:  BCF    03.6
0936:  MOVF   6F,W
0937:  BSF    03.6
0938:  MOVWF  3A
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   695
093C:  BSF    0A.3
093D:  BTFSC  03.0
093E:  GOTO   141
093F:  BTFSS  03.2
0940:  GOTO   143
....................       {
....................          //t = temp;
....................          minus=0;
0941:  BCF    47.2
....................       }
0942:  GOTO   144
....................       else
....................       {
....................          //t = temp*(-1);
....................          minus=1;
0943:  BSF    47.2
....................       }
....................       //neu nhiet do Duong
....................       if(minus==0)
0944:  BTFSC  47.2
0945:  GOTO   3FC
....................       {
....................          if((temp>=0.1)&&(temp<10))
0946:  MOVLW  CD
0947:  BSF    03.6
0948:  MOVWF  39
0949:  MOVLW  CC
094A:  MOVWF  38
094B:  MOVLW  4C
094C:  MOVWF  37
094D:  MOVLW  7B
094E:  MOVWF  36
094F:  MOVF   72,W
0950:  MOVWF  3D
0951:  MOVF   71,W
0952:  MOVWF  3C
0953:  MOVF   70,W
0954:  MOVWF  3B
0955:  BCF    03.6
0956:  MOVF   6F,W
0957:  BSF    03.6
0958:  MOVWF  3A
0959:  BCF    0A.3
095A:  BCF    03.6
095B:  CALL   695
095C:  BSF    0A.3
095D:  BTFSC  03.0
095E:  GOTO   161
095F:  BTFSS  03.2
0960:  GOTO   1F1
0961:  MOVF   72,W
0962:  BSF    03.6
0963:  MOVWF  39
0964:  MOVF   71,W
0965:  MOVWF  38
0966:  MOVF   70,W
0967:  MOVWF  37
0968:  BCF    03.6
0969:  MOVF   6F,W
096A:  BSF    03.6
096B:  MOVWF  36
096C:  CLRF   3D
096D:  CLRF   3C
096E:  MOVLW  20
096F:  MOVWF  3B
0970:  MOVLW  82
0971:  MOVWF  3A
0972:  BCF    0A.3
0973:  BCF    03.6
0974:  CALL   695
0975:  BSF    0A.3
0976:  BTFSS  03.0
0977:  GOTO   1F1
....................          {
....................             main_array[0]=11;
0978:  MOVLW  0B
0979:  MOVWF  3D
....................             main_array[1]=11;
097A:  MOVWF  3E
....................             main_array[2]=((int8)(temp)%10);
097B:  MOVF   72,W
097C:  BSF    03.6
097D:  MOVWF  35
097E:  MOVF   71,W
097F:  MOVWF  34
0980:  MOVF   70,W
0981:  MOVWF  33
0982:  BCF    03.6
0983:  MOVF   6F,W
0984:  BSF    03.6
0985:  MOVWF  32
0986:  BCF    0A.3
0987:  BCF    03.6
0988:  CALL   6D6
0989:  BSF    0A.3
098A:  MOVF   78,W
098B:  BSF    03.6
098C:  MOVWF  33
098D:  MOVLW  0A
098E:  MOVWF  34
098F:  BCF    0A.3
0990:  BCF    03.6
0991:  CALL   6F7
0992:  BSF    0A.3
0993:  MOVF   77,W
0994:  MOVWF  3F
....................             main_array[3]=((int16)(temp*10)%10);                                    
0995:  MOVF   72,W
0996:  BSF    03.6
0997:  MOVWF  35
0998:  MOVF   71,W
0999:  MOVWF  34
099A:  MOVF   70,W
099B:  MOVWF  33
099C:  BCF    03.6
099D:  MOVF   6F,W
099E:  BSF    03.6
099F:  MOVWF  32
09A0:  CLRF   39
09A1:  CLRF   38
09A2:  MOVLW  20
09A3:  MOVWF  37
09A4:  MOVLW  82
09A5:  MOVWF  36
09A6:  BCF    0A.3
09A7:  BCF    03.6
09A8:  CALL   4D8
09A9:  BSF    0A.3
09AA:  MOVF   7A,W
09AB:  BSF    03.6
09AC:  MOVWF  35
09AD:  MOVF   79,W
09AE:  MOVWF  34
09AF:  MOVF   78,W
09B0:  MOVWF  33
09B1:  MOVF   77,W
09B2:  MOVWF  32
09B3:  BCF    0A.3
09B4:  BCF    03.6
09B5:  CALL   6D6
09B6:  BSF    0A.3
09B7:  MOVF   79,W
09B8:  BSF    03.6
09B9:  MOVWF  33
09BA:  MOVF   78,W
09BB:  MOVWF  32
09BC:  MOVF   33,W
09BD:  MOVWF  35
09BE:  MOVF   32,W
09BF:  MOVWF  34
09C0:  CLRF   37
09C1:  MOVLW  0A
09C2:  MOVWF  36
09C3:  BCF    0A.3
09C4:  BCF    03.6
09C5:  CALL   70E
09C6:  BSF    0A.3
09C7:  MOVF   77,W
09C8:  MOVWF  40
....................             Daucham=1;
09C9:  BSF    2A.0
....................             big_hold_regs[0]=temp*10;
09CA:  MOVF   72,W
09CB:  BSF    03.6
09CC:  MOVWF  35
09CD:  MOVF   71,W
09CE:  MOVWF  34
09CF:  MOVF   70,W
09D0:  MOVWF  33
09D1:  BCF    03.6
09D2:  MOVF   6F,W
09D3:  BSF    03.6
09D4:  MOVWF  32
09D5:  CLRF   39
09D6:  CLRF   38
09D7:  MOVLW  20
09D8:  MOVWF  37
09D9:  MOVLW  82
09DA:  MOVWF  36
09DB:  BCF    0A.3
09DC:  BCF    03.6
09DD:  CALL   4D8
09DE:  BSF    0A.3
09DF:  MOVF   7A,W
09E0:  BSF    03.6
09E1:  MOVWF  35
09E2:  MOVF   79,W
09E3:  MOVWF  34
09E4:  MOVF   78,W
09E5:  MOVWF  33
09E6:  MOVF   77,W
09E7:  MOVWF  32
09E8:  BCF    0A.3
09E9:  BCF    03.6
09EA:  CALL   6D6
09EB:  BSF    0A.3
09EC:  MOVF   79,W
09ED:  MOVWF  4D
09EE:  MOVF   78,W
09EF:  MOVWF  4C
....................          }
09F0:  GOTO   3FB
....................          else if((temp>=10)&&(temp<100))
09F1:  BSF    03.6
09F2:  CLRF   39
09F3:  CLRF   38
09F4:  MOVLW  20
09F5:  MOVWF  37
09F6:  MOVLW  82
09F7:  MOVWF  36
09F8:  MOVF   72,W
09F9:  MOVWF  3D
09FA:  MOVF   71,W
09FB:  MOVWF  3C
09FC:  MOVF   70,W
09FD:  MOVWF  3B
09FE:  BCF    03.6
09FF:  MOVF   6F,W
0A00:  BSF    03.6
0A01:  MOVWF  3A
0A02:  BCF    0A.3
0A03:  BCF    03.6
0A04:  CALL   695
0A05:  BSF    0A.3
0A06:  BTFSC  03.0
0A07:  GOTO   20A
0A08:  BTFSS  03.2
0A09:  GOTO   2BD
0A0A:  MOVF   72,W
0A0B:  BSF    03.6
0A0C:  MOVWF  39
0A0D:  MOVF   71,W
0A0E:  MOVWF  38
0A0F:  MOVF   70,W
0A10:  MOVWF  37
0A11:  BCF    03.6
0A12:  MOVF   6F,W
0A13:  BSF    03.6
0A14:  MOVWF  36
0A15:  CLRF   3D
0A16:  CLRF   3C
0A17:  MOVLW  48
0A18:  MOVWF  3B
0A19:  MOVLW  85
0A1A:  MOVWF  3A
0A1B:  BCF    0A.3
0A1C:  BCF    03.6
0A1D:  CALL   695
0A1E:  BSF    0A.3
0A1F:  BTFSS  03.0
0A20:  GOTO   2BD
....................          {
....................             main_array[0]=11;
0A21:  MOVLW  0B
0A22:  MOVWF  3D
....................             main_array[1]=(int8)(temp/10);
0A23:  MOVF   72,W
0A24:  BSF    03.6
0A25:  MOVWF  39
0A26:  MOVF   71,W
0A27:  MOVWF  38
0A28:  MOVF   70,W
0A29:  MOVWF  37
0A2A:  BCF    03.6
0A2B:  MOVF   6F,W
0A2C:  BSF    03.6
0A2D:  MOVWF  36
0A2E:  CLRF   3D
0A2F:  CLRF   3C
0A30:  MOVLW  20
0A31:  MOVWF  3B
0A32:  MOVLW  82
0A33:  MOVWF  3A
0A34:  BCF    0A.3
0A35:  BCF    03.6
0A36:  CALL   40C
0A37:  BSF    0A.3
0A38:  MOVF   7A,W
0A39:  BSF    03.6
0A3A:  MOVWF  35
0A3B:  MOVF   79,W
0A3C:  MOVWF  34
0A3D:  MOVF   78,W
0A3E:  MOVWF  33
0A3F:  MOVF   77,W
0A40:  MOVWF  32
0A41:  BCF    0A.3
0A42:  BCF    03.6
0A43:  CALL   6D6
0A44:  BSF    0A.3
0A45:  MOVF   78,W
0A46:  MOVWF  3E
....................             main_array[2]=((int8)(temp)%10);
0A47:  MOVF   72,W
0A48:  BSF    03.6
0A49:  MOVWF  35
0A4A:  MOVF   71,W
0A4B:  MOVWF  34
0A4C:  MOVF   70,W
0A4D:  MOVWF  33
0A4E:  BCF    03.6
0A4F:  MOVF   6F,W
0A50:  BSF    03.6
0A51:  MOVWF  32
0A52:  BCF    0A.3
0A53:  BCF    03.6
0A54:  CALL   6D6
0A55:  BSF    0A.3
0A56:  MOVF   78,W
0A57:  BSF    03.6
0A58:  MOVWF  33
0A59:  MOVLW  0A
0A5A:  MOVWF  34
0A5B:  BCF    0A.3
0A5C:  BCF    03.6
0A5D:  CALL   6F7
0A5E:  BSF    0A.3
0A5F:  MOVF   77,W
0A60:  MOVWF  3F
....................             main_array[3]=((int16)(temp*10)%10);                                    
0A61:  MOVF   72,W
0A62:  BSF    03.6
0A63:  MOVWF  35
0A64:  MOVF   71,W
0A65:  MOVWF  34
0A66:  MOVF   70,W
0A67:  MOVWF  33
0A68:  BCF    03.6
0A69:  MOVF   6F,W
0A6A:  BSF    03.6
0A6B:  MOVWF  32
0A6C:  CLRF   39
0A6D:  CLRF   38
0A6E:  MOVLW  20
0A6F:  MOVWF  37
0A70:  MOVLW  82
0A71:  MOVWF  36
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   4D8
0A75:  BSF    0A.3
0A76:  MOVF   7A,W
0A77:  BSF    03.6
0A78:  MOVWF  35
0A79:  MOVF   79,W
0A7A:  MOVWF  34
0A7B:  MOVF   78,W
0A7C:  MOVWF  33
0A7D:  MOVF   77,W
0A7E:  MOVWF  32
0A7F:  BCF    0A.3
0A80:  BCF    03.6
0A81:  CALL   6D6
0A82:  BSF    0A.3
0A83:  MOVF   79,W
0A84:  BSF    03.6
0A85:  MOVWF  33
0A86:  MOVF   78,W
0A87:  MOVWF  32
0A88:  MOVF   33,W
0A89:  MOVWF  35
0A8A:  MOVF   32,W
0A8B:  MOVWF  34
0A8C:  CLRF   37
0A8D:  MOVLW  0A
0A8E:  MOVWF  36
0A8F:  BCF    0A.3
0A90:  BCF    03.6
0A91:  CALL   70E
0A92:  BSF    0A.3
0A93:  MOVF   77,W
0A94:  MOVWF  40
....................             Daucham=1;
0A95:  BSF    2A.0
....................             big_hold_regs[0]=temp*10;
0A96:  MOVF   72,W
0A97:  BSF    03.6
0A98:  MOVWF  35
0A99:  MOVF   71,W
0A9A:  MOVWF  34
0A9B:  MOVF   70,W
0A9C:  MOVWF  33
0A9D:  BCF    03.6
0A9E:  MOVF   6F,W
0A9F:  BSF    03.6
0AA0:  MOVWF  32
0AA1:  CLRF   39
0AA2:  CLRF   38
0AA3:  MOVLW  20
0AA4:  MOVWF  37
0AA5:  MOVLW  82
0AA6:  MOVWF  36
0AA7:  BCF    0A.3
0AA8:  BCF    03.6
0AA9:  CALL   4D8
0AAA:  BSF    0A.3
0AAB:  MOVF   7A,W
0AAC:  BSF    03.6
0AAD:  MOVWF  35
0AAE:  MOVF   79,W
0AAF:  MOVWF  34
0AB0:  MOVF   78,W
0AB1:  MOVWF  33
0AB2:  MOVF   77,W
0AB3:  MOVWF  32
0AB4:  BCF    0A.3
0AB5:  BCF    03.6
0AB6:  CALL   6D6
0AB7:  BSF    0A.3
0AB8:  MOVF   79,W
0AB9:  MOVWF  4D
0ABA:  MOVF   78,W
0ABB:  MOVWF  4C
....................          }
0ABC:  GOTO   3FB
....................          else if((temp>=100)&&(temp<=125))
0ABD:  BSF    03.6
0ABE:  CLRF   39
0ABF:  CLRF   38
0AC0:  MOVLW  48
0AC1:  MOVWF  37
0AC2:  MOVLW  85
0AC3:  MOVWF  36
0AC4:  MOVF   72,W
0AC5:  MOVWF  3D
0AC6:  MOVF   71,W
0AC7:  MOVWF  3C
0AC8:  MOVF   70,W
0AC9:  MOVWF  3B
0ACA:  BCF    03.6
0ACB:  MOVF   6F,W
0ACC:  BSF    03.6
0ACD:  MOVWF  3A
0ACE:  BCF    0A.3
0ACF:  BCF    03.6
0AD0:  CALL   695
0AD1:  BSF    0A.3
0AD2:  BTFSC  03.0
0AD3:  GOTO   2D6
0AD4:  BTFSS  03.2
0AD5:  GOTO   3B6
0AD6:  MOVF   72,W
0AD7:  BSF    03.6
0AD8:  MOVWF  39
0AD9:  MOVF   71,W
0ADA:  MOVWF  38
0ADB:  MOVF   70,W
0ADC:  MOVWF  37
0ADD:  BCF    03.6
0ADE:  MOVF   6F,W
0ADF:  BSF    03.6
0AE0:  MOVWF  36
0AE1:  CLRF   3D
0AE2:  CLRF   3C
0AE3:  MOVLW  7A
0AE4:  MOVWF  3B
0AE5:  MOVLW  85
0AE6:  MOVWF  3A
0AE7:  BCF    0A.3
0AE8:  BCF    03.6
0AE9:  CALL   695
0AEA:  BSF    0A.3
0AEB:  BTFSC  03.0
0AEC:  GOTO   2EF
0AED:  BTFSS  03.2
0AEE:  GOTO   3B6
....................          {
....................             main_array[0]=(int8)(temp/100);
0AEF:  MOVF   72,W
0AF0:  BSF    03.6
0AF1:  MOVWF  39
0AF2:  MOVF   71,W
0AF3:  MOVWF  38
0AF4:  MOVF   70,W
0AF5:  MOVWF  37
0AF6:  BCF    03.6
0AF7:  MOVF   6F,W
0AF8:  BSF    03.6
0AF9:  MOVWF  36
0AFA:  CLRF   3D
0AFB:  CLRF   3C
0AFC:  MOVLW  48
0AFD:  MOVWF  3B
0AFE:  MOVLW  85
0AFF:  MOVWF  3A
0B00:  BCF    0A.3
0B01:  BCF    03.6
0B02:  CALL   40C
0B03:  BSF    0A.3
0B04:  MOVF   7A,W
0B05:  BSF    03.6
0B06:  MOVWF  35
0B07:  MOVF   79,W
0B08:  MOVWF  34
0B09:  MOVF   78,W
0B0A:  MOVWF  33
0B0B:  MOVF   77,W
0B0C:  MOVWF  32
0B0D:  BCF    0A.3
0B0E:  BCF    03.6
0B0F:  CALL   6D6
0B10:  BSF    0A.3
0B11:  MOVF   78,W
0B12:  MOVWF  3D
....................             main_array[1]=(int8)(temp/10)%10;
0B13:  MOVF   72,W
0B14:  BSF    03.6
0B15:  MOVWF  39
0B16:  MOVF   71,W
0B17:  MOVWF  38
0B18:  MOVF   70,W
0B19:  MOVWF  37
0B1A:  BCF    03.6
0B1B:  MOVF   6F,W
0B1C:  BSF    03.6
0B1D:  MOVWF  36
0B1E:  CLRF   3D
0B1F:  CLRF   3C
0B20:  MOVLW  20
0B21:  MOVWF  3B
0B22:  MOVLW  82
0B23:  MOVWF  3A
0B24:  BCF    0A.3
0B25:  BCF    03.6
0B26:  CALL   40C
0B27:  BSF    0A.3
0B28:  MOVF   7A,W
0B29:  BSF    03.6
0B2A:  MOVWF  35
0B2B:  MOVF   79,W
0B2C:  MOVWF  34
0B2D:  MOVF   78,W
0B2E:  MOVWF  33
0B2F:  MOVF   77,W
0B30:  MOVWF  32
0B31:  BCF    0A.3
0B32:  BCF    03.6
0B33:  CALL   6D6
0B34:  BSF    0A.3
0B35:  MOVF   78,W
0B36:  BSF    03.6
0B37:  MOVWF  33
0B38:  MOVLW  0A
0B39:  MOVWF  34
0B3A:  BCF    0A.3
0B3B:  BCF    03.6
0B3C:  CALL   6F7
0B3D:  BSF    0A.3
0B3E:  MOVF   77,W
0B3F:  MOVWF  3E
....................             main_array[2]=(int8)(temp)%10;
0B40:  MOVF   72,W
0B41:  BSF    03.6
0B42:  MOVWF  35
0B43:  MOVF   71,W
0B44:  MOVWF  34
0B45:  MOVF   70,W
0B46:  MOVWF  33
0B47:  BCF    03.6
0B48:  MOVF   6F,W
0B49:  BSF    03.6
0B4A:  MOVWF  32
0B4B:  BCF    0A.3
0B4C:  BCF    03.6
0B4D:  CALL   6D6
0B4E:  BSF    0A.3
0B4F:  MOVF   78,W
0B50:  BSF    03.6
0B51:  MOVWF  33
0B52:  MOVLW  0A
0B53:  MOVWF  34
0B54:  BCF    0A.3
0B55:  BCF    03.6
0B56:  CALL   6F7
0B57:  BSF    0A.3
0B58:  MOVF   77,W
0B59:  MOVWF  3F
....................             main_array[3]=(int16)(temp*10)%10;
0B5A:  MOVF   72,W
0B5B:  BSF    03.6
0B5C:  MOVWF  35
0B5D:  MOVF   71,W
0B5E:  MOVWF  34
0B5F:  MOVF   70,W
0B60:  MOVWF  33
0B61:  BCF    03.6
0B62:  MOVF   6F,W
0B63:  BSF    03.6
0B64:  MOVWF  32
0B65:  CLRF   39
0B66:  CLRF   38
0B67:  MOVLW  20
0B68:  MOVWF  37
0B69:  MOVLW  82
0B6A:  MOVWF  36
0B6B:  BCF    0A.3
0B6C:  BCF    03.6
0B6D:  CALL   4D8
0B6E:  BSF    0A.3
0B6F:  MOVF   7A,W
0B70:  BSF    03.6
0B71:  MOVWF  35
0B72:  MOVF   79,W
0B73:  MOVWF  34
0B74:  MOVF   78,W
0B75:  MOVWF  33
0B76:  MOVF   77,W
0B77:  MOVWF  32
0B78:  BCF    0A.3
0B79:  BCF    03.6
0B7A:  CALL   6D6
0B7B:  BSF    0A.3
0B7C:  MOVF   79,W
0B7D:  BSF    03.6
0B7E:  MOVWF  33
0B7F:  MOVF   78,W
0B80:  MOVWF  32
0B81:  MOVF   33,W
0B82:  MOVWF  35
0B83:  MOVF   32,W
0B84:  MOVWF  34
0B85:  CLRF   37
0B86:  MOVLW  0A
0B87:  MOVWF  36
0B88:  BCF    0A.3
0B89:  BCF    03.6
0B8A:  CALL   70E
0B8B:  BSF    0A.3
0B8C:  MOVF   77,W
0B8D:  MOVWF  40
....................             Daucham=1;
0B8E:  BSF    2A.0
....................             big_hold_regs[0]=temp*10;
0B8F:  MOVF   72,W
0B90:  BSF    03.6
0B91:  MOVWF  35
0B92:  MOVF   71,W
0B93:  MOVWF  34
0B94:  MOVF   70,W
0B95:  MOVWF  33
0B96:  BCF    03.6
0B97:  MOVF   6F,W
0B98:  BSF    03.6
0B99:  MOVWF  32
0B9A:  CLRF   39
0B9B:  CLRF   38
0B9C:  MOVLW  20
0B9D:  MOVWF  37
0B9E:  MOVLW  82
0B9F:  MOVWF  36
0BA0:  BCF    0A.3
0BA1:  BCF    03.6
0BA2:  CALL   4D8
0BA3:  BSF    0A.3
0BA4:  MOVF   7A,W
0BA5:  BSF    03.6
0BA6:  MOVWF  35
0BA7:  MOVF   79,W
0BA8:  MOVWF  34
0BA9:  MOVF   78,W
0BAA:  MOVWF  33
0BAB:  MOVF   77,W
0BAC:  MOVWF  32
0BAD:  BCF    0A.3
0BAE:  BCF    03.6
0BAF:  CALL   6D6
0BB0:  BSF    0A.3
0BB1:  MOVF   79,W
0BB2:  MOVWF  4D
0BB3:  MOVF   78,W
0BB4:  MOVWF  4C
....................          }         
0BB5:  GOTO   3FB
....................          else if (temp>125)
0BB6:  BSF    03.6
0BB7:  CLRF   39
0BB8:  CLRF   38
0BB9:  MOVLW  7A
0BBA:  MOVWF  37
0BBB:  MOVLW  85
0BBC:  MOVWF  36
0BBD:  MOVF   72,W
0BBE:  MOVWF  3D
0BBF:  MOVF   71,W
0BC0:  MOVWF  3C
0BC1:  MOVF   70,W
0BC2:  MOVWF  3B
0BC3:  BCF    03.6
0BC4:  MOVF   6F,W
0BC5:  BSF    03.6
0BC6:  MOVWF  3A
0BC7:  BCF    0A.3
0BC8:  BCF    03.6
0BC9:  CALL   695
0BCA:  BSF    0A.3
0BCB:  BTFSS  03.0
0BCC:  GOTO   3DA
....................          {
....................             main_array[0]=13;
0BCD:  MOVLW  0D
0BCE:  MOVWF  3D
....................             main_array[1]=14;
0BCF:  MOVLW  0E
0BD0:  MOVWF  3E
....................             main_array[2]=14;
0BD1:  MOVWF  3F
....................             main_array[3]=17;
0BD2:  MOVLW  11
0BD3:  MOVWF  40
....................             Daucham=1;
0BD4:  BSF    2A.0
....................             big_hold_regs[0]=1260;
0BD5:  MOVLW  04
0BD6:  MOVWF  4D
0BD7:  MOVLW  EC
0BD8:  MOVWF  4C
....................          }
0BD9:  GOTO   3FB
....................          else if(temp<0.1)
0BDA:  MOVF   72,W
0BDB:  BSF    03.6
0BDC:  MOVWF  39
0BDD:  MOVF   71,W
0BDE:  MOVWF  38
0BDF:  MOVF   70,W
0BE0:  MOVWF  37
0BE1:  BCF    03.6
0BE2:  MOVF   6F,W
0BE3:  BSF    03.6
0BE4:  MOVWF  36
0BE5:  MOVLW  CD
0BE6:  MOVWF  3D
0BE7:  MOVLW  CC
0BE8:  MOVWF  3C
0BE9:  MOVLW  4C
0BEA:  MOVWF  3B
0BEB:  MOVLW  7B
0BEC:  MOVWF  3A
0BED:  BCF    0A.3
0BEE:  BCF    03.6
0BEF:  CALL   695
0BF0:  BSF    0A.3
0BF1:  BTFSS  03.0
0BF2:  GOTO   3FB
....................          {
....................             main_array[0]=11;
0BF3:  MOVLW  0B
0BF4:  MOVWF  3D
....................             main_array[1]=11;
0BF5:  MOVWF  3E
....................             main_array[2]=11;
0BF6:  MOVWF  3F
....................             main_array[3]=0;
0BF7:  CLRF   40
....................             Daucham=0;
0BF8:  BCF    2A.0
....................             big_hold_regs[0]=0;
0BF9:  CLRF   4D
0BFA:  CLRF   4C
....................          }
....................       }      
0BFB:  GOTO   5D5
....................       else//neu nhiet do Am
....................       {
....................          if((temp>(-10))&& (temp<=(-0.1)))
0BFC:  BSF    03.6
0BFD:  CLRF   39
0BFE:  CLRF   38
0BFF:  MOVLW  A0
0C00:  MOVWF  37
0C01:  MOVLW  82
0C02:  MOVWF  36
0C03:  MOVF   72,W
0C04:  MOVWF  3D
0C05:  MOVF   71,W
0C06:  MOVWF  3C
0C07:  MOVF   70,W
0C08:  MOVWF  3B
0C09:  BCF    03.6
0C0A:  MOVF   6F,W
0C0B:  BSF    03.6
0C0C:  MOVWF  3A
0C0D:  BCF    0A.3
0C0E:  BCF    03.6
0C0F:  CALL   695
0C10:  BSF    0A.3
0C11:  BTFSS  03.0
0C12:  GOTO   4C1
0C13:  MOVF   72,W
0C14:  BSF    03.6
0C15:  MOVWF  39
0C16:  MOVF   71,W
0C17:  MOVWF  38
0C18:  MOVF   70,W
0C19:  MOVWF  37
0C1A:  BCF    03.6
0C1B:  MOVF   6F,W
0C1C:  BSF    03.6
0C1D:  MOVWF  36
0C1E:  MOVLW  CD
0C1F:  MOVWF  3D
0C20:  MOVLW  CC
0C21:  MOVWF  3C
0C22:  MOVWF  3B
0C23:  MOVLW  7B
0C24:  MOVWF  3A
0C25:  BCF    0A.3
0C26:  BCF    03.6
0C27:  CALL   695
0C28:  BSF    0A.3
0C29:  BTFSC  03.0
0C2A:  GOTO   42D
0C2B:  BTFSS  03.2
0C2C:  GOTO   4C1
....................          {
....................             main_array[3]=((int16)(temp*(-10))%10);
0C2D:  MOVF   72,W
0C2E:  BSF    03.6
0C2F:  MOVWF  35
0C30:  MOVF   71,W
0C31:  MOVWF  34
0C32:  MOVF   70,W
0C33:  MOVWF  33
0C34:  BCF    03.6
0C35:  MOVF   6F,W
0C36:  BSF    03.6
0C37:  MOVWF  32
0C38:  CLRF   39
0C39:  CLRF   38
0C3A:  MOVLW  A0
0C3B:  MOVWF  37
0C3C:  MOVLW  82
0C3D:  MOVWF  36
0C3E:  BCF    0A.3
0C3F:  BCF    03.6
0C40:  CALL   4D8
0C41:  BSF    0A.3
0C42:  MOVF   7A,W
0C43:  BSF    03.6
0C44:  MOVWF  35
0C45:  MOVF   79,W
0C46:  MOVWF  34
0C47:  MOVF   78,W
0C48:  MOVWF  33
0C49:  MOVF   77,W
0C4A:  MOVWF  32
0C4B:  BCF    0A.3
0C4C:  BCF    03.6
0C4D:  CALL   6D6
0C4E:  BSF    0A.3
0C4F:  MOVF   79,W
0C50:  BSF    03.6
0C51:  MOVWF  33
0C52:  MOVF   78,W
0C53:  MOVWF  32
0C54:  MOVF   33,W
0C55:  MOVWF  35
0C56:  MOVF   32,W
0C57:  MOVWF  34
0C58:  CLRF   37
0C59:  MOVLW  0A
0C5A:  MOVWF  36
0C5B:  BCF    0A.3
0C5C:  BCF    03.6
0C5D:  CALL   70E
0C5E:  BSF    0A.3
0C5F:  MOVF   77,W
0C60:  MOVWF  40
....................             main_array[2]=(int16)(temp*(-1))%10;
0C61:  MOVF   72,W
0C62:  BSF    03.6
0C63:  MOVWF  35
0C64:  MOVF   71,W
0C65:  MOVWF  34
0C66:  MOVF   70,W
0C67:  MOVWF  33
0C68:  BCF    03.6
0C69:  MOVF   6F,W
0C6A:  BSF    03.6
0C6B:  MOVWF  32
0C6C:  CLRF   39
0C6D:  CLRF   38
0C6E:  MOVLW  80
0C6F:  MOVWF  37
0C70:  MOVLW  7F
0C71:  MOVWF  36
0C72:  BCF    0A.3
0C73:  BCF    03.6
0C74:  CALL   4D8
0C75:  BSF    0A.3
0C76:  MOVF   7A,W
0C77:  BSF    03.6
0C78:  MOVWF  35
0C79:  MOVF   79,W
0C7A:  MOVWF  34
0C7B:  MOVF   78,W
0C7C:  MOVWF  33
0C7D:  MOVF   77,W
0C7E:  MOVWF  32
0C7F:  BCF    0A.3
0C80:  BCF    03.6
0C81:  CALL   6D6
0C82:  BSF    0A.3
0C83:  MOVF   79,W
0C84:  BSF    03.6
0C85:  MOVWF  33
0C86:  MOVF   78,W
0C87:  MOVWF  32
0C88:  MOVF   33,W
0C89:  MOVWF  35
0C8A:  MOVF   32,W
0C8B:  MOVWF  34
0C8C:  CLRF   37
0C8D:  MOVLW  0A
0C8E:  MOVWF  36
0C8F:  BCF    0A.3
0C90:  BCF    03.6
0C91:  CALL   70E
0C92:  BSF    0A.3
0C93:  MOVF   77,W
0C94:  MOVWF  3F
....................             main_array[1]=10;
0C95:  MOVLW  0A
0C96:  MOVWF  3E
....................             main_array[0]=11;
0C97:  MOVLW  0B
0C98:  MOVWF  3D
....................             Daucham=1;
0C99:  BSF    2A.0
....................             big_hold_regs[0]=temp*10;
0C9A:  MOVF   72,W
0C9B:  BSF    03.6
0C9C:  MOVWF  35
0C9D:  MOVF   71,W
0C9E:  MOVWF  34
0C9F:  MOVF   70,W
0CA0:  MOVWF  33
0CA1:  BCF    03.6
0CA2:  MOVF   6F,W
0CA3:  BSF    03.6
0CA4:  MOVWF  32
0CA5:  CLRF   39
0CA6:  CLRF   38
0CA7:  MOVLW  20
0CA8:  MOVWF  37
0CA9:  MOVLW  82
0CAA:  MOVWF  36
0CAB:  BCF    0A.3
0CAC:  BCF    03.6
0CAD:  CALL   4D8
0CAE:  BSF    0A.3
0CAF:  MOVF   7A,W
0CB0:  BSF    03.6
0CB1:  MOVWF  35
0CB2:  MOVF   79,W
0CB3:  MOVWF  34
0CB4:  MOVF   78,W
0CB5:  MOVWF  33
0CB6:  MOVF   77,W
0CB7:  MOVWF  32
0CB8:  BCF    0A.3
0CB9:  BCF    03.6
0CBA:  CALL   6D6
0CBB:  BSF    0A.3
0CBC:  MOVF   79,W
0CBD:  MOVWF  4D
0CBE:  MOVF   78,W
0CBF:  MOVWF  4C
....................          }
0CC0:  GOTO   5D5
....................          else if((temp<=(-10))&& (temp>=(-55)))
0CC1:  MOVF   72,W
0CC2:  BSF    03.6
0CC3:  MOVWF  39
0CC4:  MOVF   71,W
0CC5:  MOVWF  38
0CC6:  MOVF   70,W
0CC7:  MOVWF  37
0CC8:  BCF    03.6
0CC9:  MOVF   6F,W
0CCA:  BSF    03.6
0CCB:  MOVWF  36
0CCC:  CLRF   3D
0CCD:  CLRF   3C
0CCE:  MOVLW  A0
0CCF:  MOVWF  3B
0CD0:  MOVLW  82
0CD1:  MOVWF  3A
0CD2:  BCF    0A.3
0CD3:  BCF    03.6
0CD4:  CALL   695
0CD5:  BSF    0A.3
0CD6:  BTFSC  03.0
0CD7:  GOTO   4DA
0CD8:  BTFSS  03.2
0CD9:  GOTO   5B2
0CDA:  BSF    03.6
0CDB:  CLRF   39
0CDC:  CLRF   38
0CDD:  MOVLW  DC
0CDE:  MOVWF  37
0CDF:  MOVLW  84
0CE0:  MOVWF  36
0CE1:  MOVF   72,W
0CE2:  MOVWF  3D
0CE3:  MOVF   71,W
0CE4:  MOVWF  3C
0CE5:  MOVF   70,W
0CE6:  MOVWF  3B
0CE7:  BCF    03.6
0CE8:  MOVF   6F,W
0CE9:  BSF    03.6
0CEA:  MOVWF  3A
0CEB:  BCF    0A.3
0CEC:  BCF    03.6
0CED:  CALL   695
0CEE:  BSF    0A.3
0CEF:  BTFSC  03.0
0CF0:  GOTO   4F3
0CF1:  BTFSS  03.2
0CF2:  GOTO   5B2
....................          {
....................             main_array[3]=((int16)(temp*(-10))%10);
0CF3:  MOVF   72,W
0CF4:  BSF    03.6
0CF5:  MOVWF  35
0CF6:  MOVF   71,W
0CF7:  MOVWF  34
0CF8:  MOVF   70,W
0CF9:  MOVWF  33
0CFA:  BCF    03.6
0CFB:  MOVF   6F,W
0CFC:  BSF    03.6
0CFD:  MOVWF  32
0CFE:  CLRF   39
0CFF:  CLRF   38
0D00:  MOVLW  A0
0D01:  MOVWF  37
0D02:  MOVLW  82
0D03:  MOVWF  36
0D04:  BCF    0A.3
0D05:  BCF    03.6
0D06:  CALL   4D8
0D07:  BSF    0A.3
0D08:  MOVF   7A,W
0D09:  BSF    03.6
0D0A:  MOVWF  35
0D0B:  MOVF   79,W
0D0C:  MOVWF  34
0D0D:  MOVF   78,W
0D0E:  MOVWF  33
0D0F:  MOVF   77,W
0D10:  MOVWF  32
0D11:  BCF    0A.3
0D12:  BCF    03.6
0D13:  CALL   6D6
0D14:  BSF    0A.3
0D15:  MOVF   79,W
0D16:  BSF    03.6
0D17:  MOVWF  33
0D18:  MOVF   78,W
0D19:  MOVWF  32
0D1A:  MOVF   33,W
0D1B:  MOVWF  35
0D1C:  MOVF   32,W
0D1D:  MOVWF  34
0D1E:  CLRF   37
0D1F:  MOVLW  0A
0D20:  MOVWF  36
0D21:  BCF    0A.3
0D22:  BCF    03.6
0D23:  CALL   70E
0D24:  BSF    0A.3
0D25:  MOVF   77,W
0D26:  MOVWF  40
....................             main_array[2]=(int16)(temp*(-1))%10;
0D27:  MOVF   72,W
0D28:  BSF    03.6
0D29:  MOVWF  35
0D2A:  MOVF   71,W
0D2B:  MOVWF  34
0D2C:  MOVF   70,W
0D2D:  MOVWF  33
0D2E:  BCF    03.6
0D2F:  MOVF   6F,W
0D30:  BSF    03.6
0D31:  MOVWF  32
0D32:  CLRF   39
0D33:  CLRF   38
0D34:  MOVLW  80
0D35:  MOVWF  37
0D36:  MOVLW  7F
0D37:  MOVWF  36
0D38:  BCF    0A.3
0D39:  BCF    03.6
0D3A:  CALL   4D8
0D3B:  BSF    0A.3
0D3C:  MOVF   7A,W
0D3D:  BSF    03.6
0D3E:  MOVWF  35
0D3F:  MOVF   79,W
0D40:  MOVWF  34
0D41:  MOVF   78,W
0D42:  MOVWF  33
0D43:  MOVF   77,W
0D44:  MOVWF  32
0D45:  BCF    0A.3
0D46:  BCF    03.6
0D47:  CALL   6D6
0D48:  BSF    0A.3
0D49:  MOVF   79,W
0D4A:  BSF    03.6
0D4B:  MOVWF  33
0D4C:  MOVF   78,W
0D4D:  MOVWF  32
0D4E:  MOVF   33,W
0D4F:  MOVWF  35
0D50:  MOVF   32,W
0D51:  MOVWF  34
0D52:  CLRF   37
0D53:  MOVLW  0A
0D54:  MOVWF  36
0D55:  BCF    0A.3
0D56:  BCF    03.6
0D57:  CALL   70E
0D58:  BSF    0A.3
0D59:  MOVF   77,W
0D5A:  MOVWF  3F
....................             main_array[1]=(int8)(temp*(-1))/10;
0D5B:  MOVF   72,W
0D5C:  BSF    03.6
0D5D:  MOVWF  35
0D5E:  MOVF   71,W
0D5F:  MOVWF  34
0D60:  MOVF   70,W
0D61:  MOVWF  33
0D62:  BCF    03.6
0D63:  MOVF   6F,W
0D64:  BSF    03.6
0D65:  MOVWF  32
0D66:  CLRF   39
0D67:  CLRF   38
0D68:  MOVLW  80
0D69:  MOVWF  37
0D6A:  MOVLW  7F
0D6B:  MOVWF  36
0D6C:  BCF    0A.3
0D6D:  BCF    03.6
0D6E:  CALL   4D8
0D6F:  BSF    0A.3
0D70:  MOVF   7A,W
0D71:  BSF    03.6
0D72:  MOVWF  35
0D73:  MOVF   79,W
0D74:  MOVWF  34
0D75:  MOVF   78,W
0D76:  MOVWF  33
0D77:  MOVF   77,W
0D78:  MOVWF  32
0D79:  BCF    0A.3
0D7A:  BCF    03.6
0D7B:  CALL   6D6
0D7C:  BSF    0A.3
0D7D:  MOVF   78,W
0D7E:  BSF    03.6
0D7F:  MOVWF  33
0D80:  MOVLW  0A
0D81:  MOVWF  34
0D82:  BCF    0A.3
0D83:  BCF    03.6
0D84:  CALL   6F7
0D85:  BSF    0A.3
0D86:  MOVF   78,W
0D87:  MOVWF  3E
....................             main_array[0]=10;
0D88:  MOVLW  0A
0D89:  MOVWF  3D
....................             Daucham=1;
0D8A:  BSF    2A.0
....................             big_hold_regs[0]=temp*10;
0D8B:  MOVF   72,W
0D8C:  BSF    03.6
0D8D:  MOVWF  35
0D8E:  MOVF   71,W
0D8F:  MOVWF  34
0D90:  MOVF   70,W
0D91:  MOVWF  33
0D92:  BCF    03.6
0D93:  MOVF   6F,W
0D94:  BSF    03.6
0D95:  MOVWF  32
0D96:  CLRF   39
0D97:  CLRF   38
0D98:  MOVLW  20
0D99:  MOVWF  37
0D9A:  MOVLW  82
0D9B:  MOVWF  36
0D9C:  BCF    0A.3
0D9D:  BCF    03.6
0D9E:  CALL   4D8
0D9F:  BSF    0A.3
0DA0:  MOVF   7A,W
0DA1:  BSF    03.6
0DA2:  MOVWF  35
0DA3:  MOVF   79,W
0DA4:  MOVWF  34
0DA5:  MOVF   78,W
0DA6:  MOVWF  33
0DA7:  MOVF   77,W
0DA8:  MOVWF  32
0DA9:  BCF    0A.3
0DAA:  BCF    03.6
0DAB:  CALL   6D6
0DAC:  BSF    0A.3
0DAD:  MOVF   79,W
0DAE:  MOVWF  4D
0DAF:  MOVF   78,W
0DB0:  MOVWF  4C
....................          }         
0DB1:  GOTO   5D5
....................          else if(temp<(-55))
0DB2:  MOVF   72,W
0DB3:  BSF    03.6
0DB4:  MOVWF  39
0DB5:  MOVF   71,W
0DB6:  MOVWF  38
0DB7:  MOVF   70,W
0DB8:  MOVWF  37
0DB9:  BCF    03.6
0DBA:  MOVF   6F,W
0DBB:  BSF    03.6
0DBC:  MOVWF  36
0DBD:  CLRF   3D
0DBE:  CLRF   3C
0DBF:  MOVLW  DC
0DC0:  MOVWF  3B
0DC1:  MOVLW  84
0DC2:  MOVWF  3A
0DC3:  BCF    0A.3
0DC4:  BCF    03.6
0DC5:  CALL   695
0DC6:  BSF    0A.3
0DC7:  BTFSS  03.0
0DC8:  GOTO   5D5
....................          {
....................             main_array[0]=13;
0DC9:  MOVLW  0D
0DCA:  MOVWF  3D
....................             main_array[1]=14;
0DCB:  MOVLW  0E
0DCC:  MOVWF  3E
....................             main_array[2]=14;
0DCD:  MOVWF  3F
....................             main_array[3]=18;
0DCE:  MOVLW  12
0DCF:  MOVWF  40
....................             Daucham=1;
0DD0:  BSF    2A.0
....................             big_hold_regs[0]=-56;
0DD1:  MOVLW  FF
0DD2:  MOVWF  4D
0DD3:  MOVLW  C8
0DD4:  MOVWF  4C
....................          }
....................        }     
....................    }
0DD5:  GOTO   5E2
....................    else
....................    {
....................       main_array[0]=13;
0DD6:  MOVLW  0D
0DD7:  MOVWF  3D
....................       main_array[1]=14;
0DD8:  MOVLW  0E
0DD9:  MOVWF  3E
....................       main_array[2]=14;
0DDA:  MOVWF  3F
....................       main_array[3]=5;
0DDB:  MOVLW  05
0DDC:  MOVWF  40
....................       Daucham=1;      
0DDD:  BSF    2A.0
....................       big_hold_regs[0]=9998;
0DDE:  MOVLW  27
0DDF:  MOVWF  4D
0DE0:  MOVLW  0E
0DE1:  MOVWF  4C
....................    }
0DE2:  RETURN
.................... }
.................... 
.................... 
.................... 
.................... 
.................... #include <Sev_Seg_Display.c>
.................... #include <export_595.c>
.................... void port_init(int8 *my_array_port)
.................... {
....................    //----------------------Cum dieu khien 595 thu nhat------------------------------ 
....................    output_low(my_array_port[0]); //DATA 
*
031B:  BSF    03.6
031C:  MOVF   32,W
031D:  MOVWF  04
031E:  BCF    03.7
031F:  BTFSC  33.0
0320:  BSF    03.7
0321:  MOVF   00,W
0322:  MOVWF  34
0323:  MOVWF  43
0324:  CLRF   44
0325:  CLRF   46
0326:  CLRF   45
0327:  BCF    03.6
0328:  CALL   2F9
....................    output_low(my_array_port[1]); //SCK
0329:  MOVLW  01
032A:  BSF    03.6
032B:  ADDWF  32,W
032C:  MOVWF  04
032D:  BCF    03.7
032E:  BTFSC  33.0
032F:  BSF    03.7
0330:  MOVF   00,W
0331:  MOVWF  34
0332:  MOVWF  43
0333:  CLRF   44
0334:  CLRF   46
0335:  CLRF   45
0336:  BCF    03.6
0337:  CALL   2F9
....................    output_low(my_array_port[2]); //RCK
0338:  MOVLW  02
0339:  BSF    03.6
033A:  ADDWF  32,W
033B:  MOVWF  04
033C:  BCF    03.7
033D:  BTFSC  33.0
033E:  BSF    03.7
033F:  MOVF   00,W
0340:  MOVWF  34
0341:  MOVWF  43
0342:  CLRF   44
0343:  CLRF   46
0344:  CLRF   45
0345:  BCF    03.6
0346:  CALL   2F9
0347:  BSF    0A.3
0348:  BSF    0A.4
0349:  GOTO   51F (RETURN)
.................... }
.................... //Module ham dieu khien thanh ghi dich
.................... 
.................... void load_shift_reg(int8 *shift_reg_control_array);
.................... void load_store_reg(int8 *shift_reg_control_array);
.................... #separate
.................... void send_byte(int8 data,int8 * shift_reg_control_array)
.................... {
.................... 
....................  int8 z; 
.................... 
....................  for(z = 0; z < 8; z++)                      // Send 8 bits 
*
0735:  BSF    03.6
0736:  CLRF   41
0737:  MOVF   41,W
0738:  SUBLW  07
0739:  BTFSS  03.0
073A:  GOTO   78D
....................     {    
....................      if(data & 0x80)                         //kiem tra xem bit thu 8 la 0 hay 1
073B:  BTFSS  3E.7
073C:  GOTO   752
....................        {  //neu la 1    
....................         output_high(shift_reg_control_array[0]);              //cho pin DATA len muc cao 
073D:  MOVF   3F,W
073E:  MOVWF  04
073F:  BCF    03.7
0740:  BTFSC  40.0
0741:  BSF    03.7
0742:  MOVF   00,W
0743:  MOVWF  42
0744:  MOVWF  43
0745:  MOVLW  01
0746:  MOVWF  44
0747:  CLRF   46
0748:  CLRF   45
0749:  BCF    03.6
074A:  CALL   2F9
....................         delay_us(10);
074B:  MOVLW  10
074C:  MOVWF  77
074D:  DECFSZ 77,F
074E:  GOTO   74D
074F:  NOP
....................        } 
0750:  GOTO   764
0751:  BSF    03.6
....................      else //neu la 0
....................        { 
....................         output_low(shift_reg_control_array[0]);               //cho pin DATA xuong muc thap
0752:  MOVF   3F,W
0753:  MOVWF  04
0754:  BCF    03.7
0755:  BTFSC  40.0
0756:  BSF    03.7
0757:  MOVF   00,W
0758:  MOVWF  42
0759:  MOVWF  43
075A:  CLRF   44
075B:  CLRF   46
075C:  CLRF   45
075D:  BCF    03.6
075E:  CALL   2F9
....................         delay_us(10);
075F:  MOVLW  10
0760:  MOVWF  77
0761:  DECFSZ 77,F
0762:  GOTO   761
0763:  NOP
....................        } 
.................... 
.................... 
....................        //dich du lieu
....................        output_high(shift_reg_control_array[1]); 
0764:  MOVLW  01
0765:  BSF    03.6
0766:  ADDWF  3F,W
0767:  MOVWF  04
0768:  BCF    03.7
0769:  BTFSC  40.0
076A:  BSF    03.7
076B:  MOVF   00,W
076C:  MOVWF  42
076D:  MOVWF  43
076E:  MOVLW  01
076F:  MOVWF  44
0770:  CLRF   46
0771:  CLRF   45
0772:  BCF    03.6
0773:  CALL   2F9
....................        delay_us(30);
0774:  MOVLW  31
0775:  MOVWF  77
0776:  DECFSZ 77,F
0777:  GOTO   776
0778:  GOTO   779
....................        output_low(shift_reg_control_array[1]);                 // tao 1 xung clock L to H cho SCK.
0779:  MOVLW  01
077A:  BSF    03.6
077B:  ADDWF  3F,W
077C:  MOVWF  04
077D:  BCF    03.7
077E:  BTFSC  40.0
077F:  BSF    03.7
0780:  MOVF   00,W
0781:  MOVWF  42
0782:  MOVWF  43
0783:  CLRF   44
0784:  CLRF   46
0785:  CLRF   45
0786:  BCF    03.6
0787:  CALL   2F9
....................      data <<= 1;                                               // Dich sang trai 1 bit va gan vao data      
0788:  BCF    03.0
0789:  BSF    03.6
078A:  RLF    3E,F
078B:  INCF   41,F
078C:  GOTO   737
....................    }    
078D:  BCF    03.6
078E:  BSF    0A.3
078F:  BCF    0A.4
0790:  GOTO   630 (RETURN)
.................... 
.................... }
.................... //***********************************************************************************************************************************************
....................      
.................... //****************************************Ham cho phep dua du lieu ra cac chan 595***************************************************************
.................... void load_shift_reg(int8 *shift_reg_control_array) 
.................... { 
....................    output_high(shift_reg_control_array[1]); 
....................    delay_us(30);
....................    output_low(shift_reg_control_array[1]);                 // tao 1 xung clock L to H cho SCK.
....................    
.................... }
.................... void load_store_reg(int8 *shift_reg_control_array) 
.................... { 
....................    output_high(shift_reg_control_array[2]);                 // tao 1 xung clock H to L cho RCK 
*
0E38:  MOVLW  02
0E39:  ADDWF  3D,W
0E3A:  MOVWF  04
0E3B:  BCF    03.7
0E3C:  BTFSC  3E.0
0E3D:  BSF    03.7
0E3E:  MOVF   00,W
0E3F:  MOVWF  3F
0E40:  MOVWF  43
0E41:  MOVLW  01
0E42:  MOVWF  44
0E43:  CLRF   46
0E44:  CLRF   45
0E45:  BCF    0A.3
0E46:  BCF    03.6
0E47:  CALL   2F9
0E48:  BSF    0A.3
....................    delay_ms(20);
0E49:  MOVLW  14
0E4A:  BSF    03.6
0E4B:  MOVWF  3F
0E4C:  BCF    0A.3
0E4D:  BCF    03.6
0E4E:  CALL   791
0E4F:  BSF    0A.3
....................    output_low(shift_reg_control_array[2]); 
0E50:  MOVLW  02
0E51:  BSF    03.6
0E52:  ADDWF  3D,W
0E53:  MOVWF  04
0E54:  BCF    03.7
0E55:  BTFSC  3E.0
0E56:  BSF    03.7
0E57:  MOVF   00,W
0E58:  MOVWF  3F
0E59:  MOVWF  43
0E5A:  CLRF   44
0E5B:  CLRF   46
0E5C:  CLRF   45
0E5D:  BCF    0A.3
0E5E:  BCF    03.6
0E5F:  CALL   2F9
0E60:  BSF    0A.3
.................... } 
.................... 
.................... 
.................... 
.................... 
.................... void display(int8 *mydisplay_data, int8 mysev_num, int8 *myport);
....................                                // 0,        1,          2,        3,         4,         5,        6,          7,         8,          9,    -,  "",     .,           E,         r,         t,          I,          H,          L,          d,           b,         C          O           u        A
.................... int8 const sev_seg_map[25]={0b00101000,0b01111110,0b00110001,0b00110100,0b01100110,0b10100100,0b10100000,0b00111110,0b00100000,0b00100100,0xF7,0xFF,0b00100000,0b10100001,0b11110011, 0b11100001, 0b11111110, 0b01100010, 0b11101001, 0b01110000, 0b11100000,0b10101001,0b00101000,0b11111000,0b00100010};
.................... 
.................... void display(int8 *mydisplay_data, int8 mysev_num, int8 *myport)
.................... {
....................    int8 display_buffer[MAXNUM];
....................    int8 i, j;
.................... 
....................    for(i=mysev_num-1, j=0; j<mysev_num; i--, j++)
*
0DE3:  MOVLW  01
0DE4:  BSF    03.6
0DE5:  SUBWF  34,W
0DE6:  MOVWF  3B
0DE7:  CLRF   3C
0DE8:  MOVF   34,W
0DE9:  SUBWF  3C,W
0DEA:  BTFSC  03.0
0DEB:  GOTO   60B
....................    {  
....................       display_buffer[j]=sev_seg_map[mydisplay_data[i]];  
0DEC:  MOVLW  37
0DED:  ADDWF  3C,W
0DEE:  MOVWF  3D
0DEF:  MOVLW  01
0DF0:  MOVWF  3E
0DF1:  BTFSC  03.0
0DF2:  INCF   3E,F
0DF3:  MOVF   3B,W
0DF4:  ADDWF  32,W
0DF5:  MOVWF  04
0DF6:  BCF    03.7
0DF7:  BTFSC  33.0
0DF8:  BSF    03.7
0DF9:  MOVF   00,W
0DFA:  BCF    0A.3
0DFB:  BCF    03.6
0DFC:  CALL   248
0DFD:  BSF    0A.3
0DFE:  MOVWF  78
0DFF:  BSF    03.6
0E00:  MOVF   3D,W
0E01:  MOVWF  04
0E02:  BCF    03.7
0E03:  BTFSC  3E.0
0E04:  BSF    03.7
0E05:  MOVF   78,W
0E06:  MOVWF  00
0E07:  MOVF   3B,W
0E08:  DECF   3B,F
0E09:  INCF   3C,F
0E0A:  GOTO   5E8
....................    }
....................    if(Daucham==1)
0E0B:  BCF    03.6
0E0C:  BTFSS  2A.0
0E0D:  GOTO   612
....................    {
....................       display_buffer[1]=display_buffer[1]^sev_seg_map[12]; 
0E0E:  MOVLW  20
0E0F:  BSF    03.6
0E10:  XORWF  38,F
0E11:  BCF    03.6
....................    }   
....................    if(Led_Alarm==1)
0E12:  BTFSS  2A.7
0E13:  GOTO   618
....................    {
....................       display_buffer[0]=display_buffer[0]^sev_seg_map[12]; 
0E14:  MOVLW  20
0E15:  BSF    03.6
0E16:  XORWF  37,F
0E17:  BCF    03.6
....................    }
....................    //do 3 times for ensuring
....................    for(j=0; j<1; j++)
0E18:  BSF    03.6
0E19:  CLRF   3C
0E1A:  MOVF   3C,F
0E1B:  BTFSS  03.2
0E1C:  GOTO   66B
....................    {
....................       // send byte                 
....................       for (i=0;i<mysev_num;i++)
0E1D:  CLRF   3B
0E1E:  MOVF   34,W
0E1F:  SUBWF  3B,W
0E20:  BTFSC  03.0
0E21:  GOTO   634
....................       {
....................          send_byte(display_buffer[i],myport);
0E22:  MOVLW  37
0E23:  ADDWF  3B,W
0E24:  MOVWF  04
0E25:  BSF    03.7
0E26:  MOVF   00,W
0E27:  MOVWF  3D
0E28:  MOVWF  3E
0E29:  MOVF   36,W
0E2A:  MOVWF  40
0E2B:  MOVF   35,W
0E2C:  MOVWF  3F
0E2D:  BCF    0A.3
0E2E:  BCF    03.6
0E2F:  GOTO   735
0E30:  BSF    0A.3
0E31:  BSF    03.6
0E32:  INCF   3B,F
0E33:  GOTO   61E
....................       }
....................       load_store_reg(myport);
0E34:  MOVF   36,W
0E35:  MOVWF  3E
0E36:  MOVF   35,W
0E37:  MOVWF  3D
....................       delay_ms(1);
*
0E61:  MOVLW  01
0E62:  BSF    03.6
0E63:  MOVWF  3F
0E64:  BCF    0A.3
0E65:  BCF    03.6
0E66:  CALL   791
0E67:  BSF    0A.3
0E68:  BSF    03.6
0E69:  INCF   3C,F
0E6A:  GOTO   61A
....................    }  
0E6B:  BCF    03.6
0E6C:  RETURN
.................... }
.................... 
.................... 
....................                    
.................... 
.................... 
.................... //=======================//
.................... /////////////////////////////////////////////////////////////////////////////////
.................... Void Doc_eeprom();
.................... Void Alarm_Control();
.................... Void Nutnhan();
.................... Void CaiDat();
.................... Void Calib_temp();
.................... Void Ghi_eeprom();
.................... void Apply_Changes();
.................... void main()
*
1C89:  MOVF   03,W
1C8A:  ANDLW  1F
1C8B:  MOVWF  03
1C8C:  CLRF   28
1C8D:  CLRF   29
1C8E:  BCF    2A.0
1C8F:  BCF    2A.1
1C90:  BCF    2A.2
1C91:  BCF    2A.3
1C92:  BCF    2A.4
1C93:  BCF    2A.5
1C94:  CLRF   2E
1C95:  CLRF   2F
1C96:  CLRF   30
1C97:  CLRF   34
1C98:  CLRF   33
1C99:  CLRF   32
1C9A:  CLRF   31
1C9B:  CLRF   38
1C9C:  CLRF   37
1C9D:  CLRF   36
1C9E:  CLRF   35
1C9F:  CLRF   39
1CA0:  CLRF   3A
1CA1:  CLRF   3B
1CA2:  CLRF   3C
1CA3:  BCF    2A.6
1CA4:  BCF    2A.7
1CA5:  CLRF   46
1CA6:  BSF    03.5
1CA7:  BSF    03.6
1CA8:  BSF    07.3
1CA9:  MOVLW  08
1CAA:  BCF    03.6
1CAB:  MOVWF  19
1CAC:  MOVLW  02
1CAD:  MOVWF  1A
1CAE:  MOVLW  A6
1CAF:  MOVWF  18
1CB0:  MOVLW  90
1CB1:  BCF    03.5
1CB2:  MOVWF  18
1CB3:  BCF    47.0
1CB4:  CLRF   48
1CB5:  MOVLW  FF
1CB6:  MOVWF  4B
1CB7:  MOVLW  07
1CB8:  MOVWF  5A
1CB9:  CLRF   5E
1CBA:  CLRF   5D
1CBB:  CLRF   5C
1CBC:  CLRF   5B
1CBD:  CLRF   62
1CBE:  CLRF   61
1CBF:  CLRF   60
1CC0:  CLRF   5F
1CC1:  CLRF   66
1CC2:  CLRF   65
1CC3:  CLRF   64
1CC4:  MOVLW  06
1CC5:  MOVWF  63
1CC6:  BCF    47.1
1CC7:  BCF    47.2
1CC8:  CLRF   72
1CC9:  CLRF   71
1CCA:  CLRF   70
1CCB:  CLRF   6F
1CCC:  BSF    03.5
1CCD:  BSF    03.6
1CCE:  MOVF   09,W
1CCF:  ANDLW  C0
1CD0:  MOVWF  09
1CD1:  BCF    03.6
1CD2:  BCF    1F.4
1CD3:  BCF    1F.5
1CD4:  MOVLW  00
1CD5:  BSF    03.6
1CD6:  MOVWF  08
1CD7:  BCF    03.5
1CD8:  CLRF   07
1CD9:  CLRF   08
1CDA:  CLRF   09
1CDB:  BCF    03.7
.................... {  
....................    enable_interrupts(GLOBAL);
*
1CEC:  MOVLW  C0
1CED:  IORWF  0B,F
....................    setup_adc_ports( NO_ANALOGS);
1CEE:  BSF    03.5
1CEF:  BSF    03.6
1CF0:  MOVF   09,W
1CF1:  ANDLW  C0
1CF2:  MOVWF  09
1CF3:  BCF    03.6
1CF4:  BCF    1F.4
1CF5:  BCF    1F.5
1CF6:  MOVLW  00
1CF7:  BSF    03.6
1CF8:  MOVWF  08
....................    set_tris_a(0);
1CF9:  BCF    03.6
1CFA:  MOVWF  05
....................    set_tris_b(0);
1CFB:  MOVWF  06
....................    set_tris_c(0);
1CFC:  MOVWF  07
1CFD:  BCF    03.5
1CFE:  MOVWF  4B
....................    set_tris_d(0b11110000);
1CFF:  MOVLW  F0
1D00:  BSF    03.5
1D01:  MOVWF  08
....................    set_tris_e(0);
1D02:  BCF    09.0
1D03:  BCF    09.1
1D04:  BCF    09.2
1D05:  BCF    09.3
....................    
....................    output_a(0);
1D06:  BCF    03.5
1D07:  CLRF   05
....................    output_b(0);
1D08:  CLRF   06
....................    output_c(0);
1D09:  MOVLW  00
1D0A:  MOVWF  4B
1D0B:  BSF    03.5
1D0C:  CLRF   07
1D0D:  BCF    03.5
1D0E:  CLRF   07
....................    output_d(0);
1D0F:  CLRF   08
....................    output_e(0);   
1D10:  BSF    03.5
1D11:  BCF    09.0
1D12:  BCF    09.1
1D13:  BCF    09.2
1D14:  BCF    09.3
1D15:  BCF    03.5
1D16:  CLRF   09
....................    port_init(control_array);  
1D17:  BSF    03.6
1D18:  CLRF   33
1D19:  MOVLW  2B
1D1A:  MOVWF  32
1D1B:  BCF    0A.4
1D1C:  BCF    0A.3
1D1D:  BCF    03.6
1D1E:  GOTO   31B
1D1F:  BSF    0A.4
1D20:  BSF    0A.3
....................    Setup_WDT(WDT_2304MS);
1D21:  MOVLW  09
1D22:  BSF    03.6
1D23:  MOVWF  05
1D24:  MOVLW  0F
1D25:  MOVWF  77
1D26:  BCF    03.6
1D27:  CLRF   01
1D28:  MOVLW  81
1D29:  MOVWF  04
1D2A:  BCF    03.7
1D2B:  MOVF   00,W
1D2C:  ANDLW  F0
1D2D:  IORLW  07
1D2E:  MOVWF  00
1D2F:  CLRWDT
1D30:  MOVF   00,W
1D31:  ANDLW  F7
1D32:  BTFSC  77.3
1D33:  ANDLW  F0
1D34:  IORWF  77,W
1D35:  MOVWF  00
....................    Get_temp();
1D36:  BCF    0A.4
1D37:  CALL   000
1D38:  BSF    0A.4
....................    daucham=0;
1D39:  BCF    2A.0
....................    main_array[0] = 11;
1D3A:  MOVLW  0B
1D3B:  MOVWF  3D
....................    main_array[1] = 11;
1D3C:  MOVWF  3E
....................    main_array[2] = 16;
1D3D:  MOVLW  10
1D3E:  MOVWF  3F
....................    main_array[3] = 19;
1D3F:  MOVLW  13
1D40:  MOVWF  40
....................    display(main_array, MAXNUM, control_array);  
1D41:  BSF    03.6
1D42:  CLRF   33
1D43:  MOVLW  3D
1D44:  MOVWF  32
1D45:  MOVLW  04
1D46:  MOVWF  34
1D47:  CLRF   36
1D48:  MOVLW  2B
1D49:  MOVWF  35
1D4A:  BCF    0A.4
1D4B:  BCF    03.6
1D4C:  CALL   5E3
1D4D:  BSF    0A.4
....................    delay_ms(1000);
1D4E:  MOVLW  04
1D4F:  BSF    03.6
1D50:  MOVWF  32
1D51:  MOVLW  FA
1D52:  MOVWF  3F
1D53:  BCF    0A.4
1D54:  BCF    0A.3
1D55:  BCF    03.6
1D56:  CALL   791
1D57:  BSF    0A.4
1D58:  BSF    0A.3
1D59:  BSF    03.6
1D5A:  DECFSZ 32,F
1D5B:  GOTO   551
....................    main_array[0] = 11;
1D5C:  MOVLW  0B
1D5D:  BCF    03.6
1D5E:  MOVWF  3D
....................    main_array[1] = 11;
1D5F:  MOVWF  3E
....................    main_array[2] = MODBUS_ADDRESS/10;
1D60:  MOVLW  05
1D61:  MOVWF  3F
....................    main_array[3] = MODBUS_ADDRESS%10;   
1D62:  CLRF   40
....................    display(main_array, MAXNUM, control_array);     
1D63:  BSF    03.6
1D64:  CLRF   33
1D65:  MOVLW  3D
1D66:  MOVWF  32
1D67:  MOVLW  04
1D68:  MOVWF  34
1D69:  CLRF   36
1D6A:  MOVLW  2B
1D6B:  MOVWF  35
1D6C:  BCF    0A.4
1D6D:  BCF    03.6
1D6E:  CALL   5E3
1D6F:  BSF    0A.4
....................    delay_ms(1000);
1D70:  MOVLW  04
1D71:  BSF    03.6
1D72:  MOVWF  32
1D73:  MOVLW  FA
1D74:  MOVWF  3F
1D75:  BCF    0A.4
1D76:  BCF    0A.3
1D77:  BCF    03.6
1D78:  CALL   791
1D79:  BSF    0A.4
1D7A:  BSF    0A.3
1D7B:  BSF    03.6
1D7C:  DECFSZ 32,F
1D7D:  GOTO   573
....................    Get_temp();
1D7E:  BCF    0A.4
1D7F:  BCF    03.6
1D80:  CALL   000
1D81:  BSF    0A.4
....................    // Modbus init
....................    modbus_init();      
1D82:  BCF    0A.4
1D83:  BCF    0A.3
1D84:  GOTO   7B4
1D85:  BSF    0A.4
1D86:  BSF    0A.3
....................    big_hold_regs[6]=0;
1D87:  CLRF   59
1D88:  CLRF   58
....................    Doc_eeprom();
1D89:  BCF    0A.3
1D8A:  GOTO   000
1D8B:  BSF    0A.3
....................    While(true)
....................    {                     
....................       restart_wdt();
1D8C:  CLRWDT
....................       if(Count_ReadTemp==0)
1D8D:  BTFSC  2A.6
1D8E:  GOTO   774
....................       {
....................          if(modbus_kbhit())
1D8F:  BCF    0A.4
1D90:  GOTO   66D
1D91:  BSF    0A.4
1D92:  MOVF   78,F
1D93:  BTFSC  03.2
1D94:  GOTO   764
....................          {          
....................             modbus_process();
....................             if(Config==0)
*
1F60:  BCF    03.5
1F61:  MOVF   30,F
1F62:  BTFSC  03.2
....................             {
....................                Modbus_update=1;
1F63:  BSF    2A.1
....................             }
....................          }  
....................          if(Modbus_update==1)
1F64:  BTFSS  2A.1
1F65:  GOTO   76A
....................          {
....................             Apply_Changes(); 
1F66:  BCF    0A.4
1F67:  GOTO   724
1F68:  BSF    0A.4
....................             Modbus_update=0;      
1F69:  BCF    2A.1
....................          }
....................          delay_ms(100);
1F6A:  MOVLW  64
1F6B:  BSF    03.6
1F6C:  MOVWF  3F
1F6D:  BCF    0A.4
1F6E:  BCF    0A.3
1F6F:  BCF    03.6
1F70:  CALL   791
1F71:  BSF    0A.4
1F72:  BSF    0A.3
....................          Count_ReadTemp=1;
1F73:  BSF    2A.6
....................       }
....................       if(Config==0)
1F74:  MOVF   30,F
1F75:  BTFSS  03.2
1F76:  GOTO   7A6
....................       {       
....................          if(Count_ReadTemp==1)
1F77:  BTFSS  2A.6
1F78:  GOTO   78C
....................          {
....................             disable_interrupts(GLOBAL);
1F79:  BCF    0B.6
1F7A:  BCF    0B.7
1F7B:  BTFSC  0B.7
1F7C:  GOTO   77A
....................             Get_temp();
1F7D:  BCF    0A.4
1F7E:  CALL   000
1F7F:  BSF    0A.4
....................             Delay_ms(100);
1F80:  MOVLW  64
1F81:  BSF    03.6
1F82:  MOVWF  3F
1F83:  BCF    0A.4
1F84:  BCF    0A.3
1F85:  BCF    03.6
1F86:  CALL   791
1F87:  BSF    0A.4
1F88:  BSF    0A.3
....................             Count_ReadTemp=0;
1F89:  BCF    2A.6
....................             enable_interrupts(GLOBAL);
1F8A:  MOVLW  C0
1F8B:  IORWF  0B,F
....................          }
....................          display(main_array, MAXNUM, control_array);
1F8C:  BSF    03.6
1F8D:  CLRF   33
1F8E:  MOVLW  3D
1F8F:  MOVWF  32
1F90:  MOVLW  04
1F91:  MOVWF  34
1F92:  CLRF   36
1F93:  MOVLW  2B
1F94:  MOVWF  35
1F95:  BCF    0A.4
1F96:  BCF    03.6
1F97:  CALL   5E3
1F98:  BSF    0A.4
....................          Alarm_Control();
1F99:  BCF    0A.3
1F9A:  GOTO   237
1F9B:  BSF    0A.3
....................          Nutnhan();
1F9C:  BCF    0A.4
1F9D:  GOTO   7B7
1F9E:  BSF    0A.4
....................          if(Ghi_Rom==1)
1F9F:  BTFSS  2A.2
1FA0:  GOTO   7A5
....................          {
....................             Ghi_eeprom();
1FA1:  BCF    0A.3
1FA2:  GOTO   419
1FA3:  BSF    0A.3
....................             Ghi_Rom=0;
1FA4:  BCF    2A.2
....................          }
....................       }
1FA5:  GOTO   7AE
....................       else if(Config==1)
1FA6:  DECFSZ 30,W
1FA7:  GOTO   7AA
....................       {                   
....................          CaiDat(); 
1FA8:  GOTO   000
....................       }
1FA9:  GOTO   7AE
....................       else if ( config>1)      
1FAA:  MOVF   30,W
1FAB:  SUBLW  01
1FAC:  BTFSS  03.0
....................       {
....................          Config=0;
1FAD:  CLRF   30
....................       }
1FAE:  GOTO   58C
....................    }
.................... }
.................... Void Doc_eeprom()
1FAF:  SLEEP
.................... {
....................    //Read EEProm for offset values
....................    // High Alarm
....................    for(i=0;i<3;i++)
*
1000:  CLRF   28
1001:  MOVF   28,W
1002:  SUBLW  02
1003:  BTFSS  03.0
1004:  GOTO   045
....................    {
....................       main_array[i]=read_eeprom(i);            
1005:  MOVLW  3D
1006:  ADDWF  28,W
1007:  MOVWF  04
1008:  BCF    03.7
1009:  MOVF   28,W
100A:  BSF    03.6
100B:  MOVWF  0D
100C:  BSF    03.5
100D:  BCF    0C.7
100E:  BSF    0C.0
100F:  BCF    03.5
1010:  MOVF   0C,W
1011:  MOVWF  00
....................       //anti noise
....................       if(i==0)
1012:  BCF    03.6
1013:  MOVF   28,F
1014:  BTFSS  03.2
1015:  GOTO   017
....................       {
....................          continue;
1016:  GOTO   043
....................       }
....................       
....................       if(main_array[i]>9)
1017:  MOVLW  3D
1018:  ADDWF  28,W
1019:  MOVWF  04
101A:  BCF    03.7
101B:  MOVF   00,W
101C:  SUBLW  09
101D:  BTFSC  03.0
101E:  GOTO   043
....................       {
....................          main_array[i]=0;//if there is any noise - > change to "0"
101F:  MOVLW  3D
1020:  ADDWF  28,W
1021:  MOVWF  04
1022:  BCF    03.7
1023:  CLRF   00
....................          write_eeprom(i,main_array[i]);
1024:  MOVLW  3D
1025:  ADDWF  28,W
1026:  MOVWF  04
1027:  BCF    03.7
1028:  MOVF   00,W
1029:  BSF    03.6
102A:  MOVWF  32
102B:  BCF    03.6
102C:  MOVF   0B,W
102D:  MOVWF  77
102E:  BCF    0B.7
102F:  MOVF   28,W
1030:  BSF    03.6
1031:  MOVWF  0D
1032:  MOVF   32,W
1033:  MOVWF  0C
1034:  BSF    03.5
1035:  BCF    0C.7
1036:  BSF    0C.2
1037:  MOVLW  55
1038:  MOVWF  0D
1039:  MOVLW  AA
103A:  MOVWF  0D
103B:  BSF    0C.1
103C:  BTFSC  0C.1
103D:  GOTO   03C
103E:  BCF    0C.2
103F:  MOVF   77,W
1040:  BCF    03.5
1041:  BCF    03.6
1042:  IORWF  0B,F
....................       }
1043:  INCF   28,F
1044:  GOTO   001
....................    }               
....................    if(main_array[0] == 10)
1045:  MOVF   3D,W
1046:  SUBLW  0A
1047:  BTFSS  03.2
1048:  GOTO   076
....................    {
....................       high_temp = ((float)(main_array[1]*10+main_array[2]));
1049:  MOVF   3E,W
104A:  BSF    03.6
104B:  MOVWF  33
104C:  MOVLW  0A
104D:  MOVWF  34
104E:  BCF    0A.4
104F:  BCF    03.6
1050:  CALL   7C8
1051:  BSF    0A.4
1052:  MOVF   3F,W
1053:  ADDWF  78,W
1054:  BSF    03.6
1055:  CLRF   33
1056:  MOVWF  32
1057:  BCF    0A.4
1058:  BCF    03.6
1059:  CALL   3ED
105A:  BSF    0A.4
105B:  MOVF   7A,W
105C:  BSF    03.6
105D:  MOVWF  35
105E:  MOVF   79,W
105F:  MOVWF  34
1060:  MOVF   78,W
1061:  MOVWF  33
1062:  MOVF   77,W
1063:  MOVWF  32
1064:  BCF    0A.4
1065:  BCF    03.6
1066:  CALL   6D6
1067:  BSF    0A.4
1068:  MOVF   78,W
1069:  MOVWF  39
....................       high_temp = high_temp*(-1);
106A:  MOVF   39,W
106B:  BSF    03.6
106C:  MOVWF  33
106D:  MOVLW  FF
106E:  MOVWF  34
106F:  BCF    0A.4
1070:  BCF    03.6
1071:  CALL   7C8
1072:  BSF    0A.4
1073:  MOVF   78,W
1074:  MOVWF  39
....................    }
1075:  GOTO   0A7
....................    else
....................    {
....................       high_temp = (float)(main_array[0]*100 + main_array[1]*10 + main_array[2]);
1076:  MOVF   3D,W
1077:  BSF    03.6
1078:  MOVWF  33
1079:  MOVLW  64
107A:  MOVWF  34
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   7C8
107E:  BSF    0A.4
107F:  MOVF   78,W
1080:  BSF    03.6
1081:  MOVWF  32
1082:  BCF    03.6
1083:  MOVF   3E,W
1084:  BSF    03.6
1085:  MOVWF  33
1086:  MOVLW  0A
1087:  MOVWF  34
1088:  BCF    0A.4
1089:  BCF    03.6
108A:  CALL   7C8
108B:  BSF    0A.4
108C:  MOVF   78,W
108D:  BSF    03.6
108E:  ADDWF  32,W
108F:  BCF    03.6
1090:  ADDWF  3F,W
1091:  BSF    03.6
1092:  CLRF   33
1093:  MOVWF  32
1094:  BCF    0A.4
1095:  BCF    03.6
1096:  CALL   3ED
1097:  BSF    0A.4
1098:  MOVF   7A,W
1099:  BSF    03.6
109A:  MOVWF  35
109B:  MOVF   79,W
109C:  MOVWF  34
109D:  MOVF   78,W
109E:  MOVWF  33
109F:  MOVF   77,W
10A0:  MOVWF  32
10A1:  BCF    0A.4
10A2:  BCF    03.6
10A3:  CALL   6D6
10A4:  BSF    0A.4
10A5:  MOVF   78,W
10A6:  MOVWF  39
....................    }
....................    big_hold_regs[1]=high_temp;
10A7:  CLRF   7A
10A8:  MOVF   39,W
10A9:  BTFSC  39.7
10AA:  DECF   7A,F
10AB:  MOVWF  4E
10AC:  MOVF   7A,W
10AD:  MOVWF  4F
....................    // Low Alarm
....................    for(i=0;i<3;i++)
10AE:  CLRF   28
10AF:  MOVF   28,W
10B0:  SUBLW  02
10B1:  BTFSS  03.0
10B2:  GOTO   0FB
....................    {
....................       main_array[i]=read_eeprom(i+3);            
10B3:  MOVLW  3D
10B4:  ADDWF  28,W
10B5:  MOVWF  04
10B6:  BCF    03.7
10B7:  MOVLW  03
10B8:  ADDWF  28,W
10B9:  BSF    03.6
10BA:  MOVWF  34
10BB:  MOVF   34,W
10BC:  MOVWF  0D
10BD:  BSF    03.5
10BE:  BCF    0C.7
10BF:  BSF    0C.0
10C0:  BCF    03.5
10C1:  MOVF   0C,W
10C2:  MOVWF  00
....................       //anti noise
....................       if(i==0)
10C3:  BCF    03.6
10C4:  MOVF   28,F
10C5:  BTFSS  03.2
10C6:  GOTO   0C8
....................       {
....................          continue;
10C7:  GOTO   0F9
....................       }      
....................       if(main_array[i]>9)
10C8:  MOVLW  3D
10C9:  ADDWF  28,W
10CA:  MOVWF  04
10CB:  BCF    03.7
10CC:  MOVF   00,W
10CD:  SUBLW  09
10CE:  BTFSC  03.0
10CF:  GOTO   0F9
....................       {
....................          main_array[i]=0;//if there is any noise - > change to "0"
10D0:  MOVLW  3D
10D1:  ADDWF  28,W
10D2:  MOVWF  04
10D3:  BCF    03.7
10D4:  CLRF   00
....................          write_eeprom(i+3,main_array[i]);
10D5:  MOVLW  03
10D6:  ADDWF  28,W
10D7:  BSF    03.6
10D8:  MOVWF  32
10D9:  MOVLW  3D
10DA:  BCF    03.6
10DB:  ADDWF  28,W
10DC:  MOVWF  04
10DD:  BCF    03.7
10DE:  MOVF   00,W
10DF:  BSF    03.6
10E0:  MOVWF  33
10E1:  BCF    03.6
10E2:  MOVF   0B,W
10E3:  MOVWF  77
10E4:  BCF    0B.7
10E5:  BSF    03.6
10E6:  MOVF   32,W
10E7:  MOVWF  0D
10E8:  MOVF   33,W
10E9:  MOVWF  0C
10EA:  BSF    03.5
10EB:  BCF    0C.7
10EC:  BSF    0C.2
10ED:  MOVLW  55
10EE:  MOVWF  0D
10EF:  MOVLW  AA
10F0:  MOVWF  0D
10F1:  BSF    0C.1
10F2:  BTFSC  0C.1
10F3:  GOTO   0F2
10F4:  BCF    0C.2
10F5:  MOVF   77,W
10F6:  BCF    03.5
10F7:  BCF    03.6
10F8:  IORWF  0B,F
....................       }
10F9:  INCF   28,F
10FA:  GOTO   0AF
....................    }               
....................    if(main_array[0] == 10)
10FB:  MOVF   3D,W
10FC:  SUBLW  0A
10FD:  BTFSS  03.2
10FE:  GOTO   12C
....................    {
....................       low_temp = ((float)(main_array[1]*10+main_array[2]));
10FF:  MOVF   3E,W
1100:  BSF    03.6
1101:  MOVWF  33
1102:  MOVLW  0A
1103:  MOVWF  34
1104:  BCF    0A.4
1105:  BCF    03.6
1106:  CALL   7C8
1107:  BSF    0A.4
1108:  MOVF   3F,W
1109:  ADDWF  78,W
110A:  BSF    03.6
110B:  CLRF   33
110C:  MOVWF  32
110D:  BCF    0A.4
110E:  BCF    03.6
110F:  CALL   3ED
1110:  BSF    0A.4
1111:  MOVF   7A,W
1112:  BSF    03.6
1113:  MOVWF  35
1114:  MOVF   79,W
1115:  MOVWF  34
1116:  MOVF   78,W
1117:  MOVWF  33
1118:  MOVF   77,W
1119:  MOVWF  32
111A:  BCF    0A.4
111B:  BCF    03.6
111C:  CALL   6D6
111D:  BSF    0A.4
111E:  MOVF   78,W
111F:  MOVWF  3A
....................       low_temp = low_temp*(-1);
1120:  MOVF   3A,W
1121:  BSF    03.6
1122:  MOVWF  33
1123:  MOVLW  FF
1124:  MOVWF  34
1125:  BCF    0A.4
1126:  BCF    03.6
1127:  CALL   7C8
1128:  BSF    0A.4
1129:  MOVF   78,W
112A:  MOVWF  3A
....................    }
112B:  GOTO   15D
....................    else
....................    {
....................       low_temp = (float)(main_array[0]*100 + main_array[1]*10 + main_array[2]);
112C:  MOVF   3D,W
112D:  BSF    03.6
112E:  MOVWF  33
112F:  MOVLW  64
1130:  MOVWF  34
1131:  BCF    0A.4
1132:  BCF    03.6
1133:  CALL   7C8
1134:  BSF    0A.4
1135:  MOVF   78,W
1136:  BSF    03.6
1137:  MOVWF  32
1138:  BCF    03.6
1139:  MOVF   3E,W
113A:  BSF    03.6
113B:  MOVWF  33
113C:  MOVLW  0A
113D:  MOVWF  34
113E:  BCF    0A.4
113F:  BCF    03.6
1140:  CALL   7C8
1141:  BSF    0A.4
1142:  MOVF   78,W
1143:  BSF    03.6
1144:  ADDWF  32,W
1145:  BCF    03.6
1146:  ADDWF  3F,W
1147:  BSF    03.6
1148:  CLRF   33
1149:  MOVWF  32
114A:  BCF    0A.4
114B:  BCF    03.6
114C:  CALL   3ED
114D:  BSF    0A.4
114E:  MOVF   7A,W
114F:  BSF    03.6
1150:  MOVWF  35
1151:  MOVF   79,W
1152:  MOVWF  34
1153:  MOVF   78,W
1154:  MOVWF  33
1155:  MOVF   77,W
1156:  MOVWF  32
1157:  BCF    0A.4
1158:  BCF    03.6
1159:  CALL   6D6
115A:  BSF    0A.4
115B:  MOVF   78,W
115C:  MOVWF  3A
....................    }
....................    big_hold_regs[2]=low_temp;
115D:  CLRF   7A
115E:  MOVF   3A,W
115F:  BTFSC  3A.7
1160:  DECF   7A,F
1161:  MOVWF  50
1162:  MOVF   7A,W
1163:  MOVWF  51
....................    // Deadband
....................    Deadband = read_eeprom(6);
1164:  MOVLW  06
1165:  BSF    03.6
1166:  MOVWF  0D
1167:  BSF    03.5
1168:  BCF    0C.7
1169:  BSF    0C.0
116A:  BCF    03.5
116B:  MOVF   0C,W
116C:  CLRF   33
116D:  MOVWF  32
116E:  BCF    0A.4
116F:  BCF    03.6
1170:  CALL   3ED
1171:  BSF    0A.4
1172:  MOVF   7A,W
1173:  MOVWF  38
1174:  MOVF   79,W
1175:  MOVWF  37
1176:  MOVF   78,W
1177:  MOVWF  36
1178:  MOVF   77,W
1179:  MOVWF  35
....................    big_hold_regs[3]=Deadband;
117A:  MOVF   38,W
117B:  BSF    03.6
117C:  MOVWF  35
117D:  BCF    03.6
117E:  MOVF   37,W
117F:  BSF    03.6
1180:  MOVWF  34
1181:  BCF    03.6
1182:  MOVF   36,W
1183:  BSF    03.6
1184:  MOVWF  33
1185:  BCF    03.6
1186:  MOVF   35,W
1187:  BSF    03.6
1188:  MOVWF  32
1189:  BCF    0A.4
118A:  BCF    03.6
118B:  CALL   6D6
118C:  BSF    0A.4
118D:  MOVF   79,W
118E:  MOVWF  53
118F:  MOVF   78,W
1190:  MOVWF  52
....................    // Calib
....................    for(i=0;i<3;i++)
1191:  CLRF   28
1192:  MOVF   28,W
1193:  SUBLW  02
1194:  BTFSS  03.0
1195:  GOTO   1DE
....................    {
....................       main_array[i]=read_eeprom(i+7);            
1196:  MOVLW  3D
1197:  ADDWF  28,W
1198:  MOVWF  04
1199:  BCF    03.7
119A:  MOVLW  07
119B:  ADDWF  28,W
119C:  BSF    03.6
119D:  MOVWF  34
119E:  MOVF   34,W
119F:  MOVWF  0D
11A0:  BSF    03.5
11A1:  BCF    0C.7
11A2:  BSF    0C.0
11A3:  BCF    03.5
11A4:  MOVF   0C,W
11A5:  MOVWF  00
....................       //anti noise
....................       if(i==0)
11A6:  BCF    03.6
11A7:  MOVF   28,F
11A8:  BTFSS  03.2
11A9:  GOTO   1AB
....................       {
....................          continue;
11AA:  GOTO   1DC
....................       }
....................       
....................       if(main_array[i]>9)
11AB:  MOVLW  3D
11AC:  ADDWF  28,W
11AD:  MOVWF  04
11AE:  BCF    03.7
11AF:  MOVF   00,W
11B0:  SUBLW  09
11B1:  BTFSC  03.0
11B2:  GOTO   1DC
....................       {
....................          main_array[i]=0;//if there is any noise - > change to "0"
11B3:  MOVLW  3D
11B4:  ADDWF  28,W
11B5:  MOVWF  04
11B6:  BCF    03.7
11B7:  CLRF   00
....................          write_eeprom(i+7,main_array[i]);
11B8:  MOVLW  07
11B9:  ADDWF  28,W
11BA:  BSF    03.6
11BB:  MOVWF  32
11BC:  MOVLW  3D
11BD:  BCF    03.6
11BE:  ADDWF  28,W
11BF:  MOVWF  04
11C0:  BCF    03.7
11C1:  MOVF   00,W
11C2:  BSF    03.6
11C3:  MOVWF  33
11C4:  BCF    03.6
11C5:  MOVF   0B,W
11C6:  MOVWF  77
11C7:  BCF    0B.7
11C8:  BSF    03.6
11C9:  MOVF   32,W
11CA:  MOVWF  0D
11CB:  MOVF   33,W
11CC:  MOVWF  0C
11CD:  BSF    03.5
11CE:  BCF    0C.7
11CF:  BSF    0C.2
11D0:  MOVLW  55
11D1:  MOVWF  0D
11D2:  MOVLW  AA
11D3:  MOVWF  0D
11D4:  BSF    0C.1
11D5:  BTFSC  0C.1
11D6:  GOTO   1D5
11D7:  BCF    0C.2
11D8:  MOVF   77,W
11D9:  BCF    03.5
11DA:  BCF    03.6
11DB:  IORWF  0B,F
....................       }
11DC:  INCF   28,F
11DD:  GOTO   192
....................    }               
....................    temp_offset = ((float)(main_array[1]*10+main_array[2]));
11DE:  MOVF   3E,W
11DF:  BSF    03.6
11E0:  MOVWF  33
11E1:  MOVLW  0A
11E2:  MOVWF  34
11E3:  BCF    0A.4
11E4:  BCF    03.6
11E5:  CALL   7C8
11E6:  BSF    0A.4
11E7:  MOVF   3F,W
11E8:  ADDWF  78,W
11E9:  BSF    03.6
11EA:  CLRF   33
11EB:  MOVWF  32
11EC:  BCF    0A.4
11ED:  BCF    03.6
11EE:  CALL   3ED
11EF:  BSF    0A.4
11F0:  MOVF   7A,W
11F1:  MOVWF  34
11F2:  MOVF   79,W
11F3:  MOVWF  33
11F4:  MOVF   78,W
11F5:  MOVWF  32
11F6:  MOVF   77,W
11F7:  MOVWF  31
....................    if(main_array[0] == 10)
11F8:  MOVF   3D,W
11F9:  SUBLW  0A
11FA:  BTFSS  03.2
11FB:  GOTO   21D
....................    {
....................       temp_offset = temp_offset*(-1);
11FC:  MOVF   34,W
11FD:  BSF    03.6
11FE:  MOVWF  35
11FF:  BCF    03.6
1200:  MOVF   33,W
1201:  BSF    03.6
1202:  MOVWF  34
1203:  BCF    03.6
1204:  MOVF   32,W
1205:  BSF    03.6
1206:  MOVWF  33
1207:  BCF    03.6
1208:  MOVF   31,W
1209:  BSF    03.6
120A:  MOVWF  32
120B:  CLRF   39
120C:  CLRF   38
120D:  MOVLW  80
120E:  MOVWF  37
120F:  MOVLW  7F
1210:  MOVWF  36
1211:  BCF    0A.4
1212:  BCF    03.6
1213:  CALL   4D8
1214:  BSF    0A.4
1215:  MOVF   7A,W
1216:  MOVWF  34
1217:  MOVF   79,W
1218:  MOVWF  33
1219:  MOVF   78,W
121A:  MOVWF  32
121B:  MOVF   77,W
121C:  MOVWF  31
....................    }
....................    big_hold_regs[4]=Temp_offset;
121D:  MOVF   34,W
121E:  BSF    03.6
121F:  MOVWF  35
1220:  BCF    03.6
1221:  MOVF   33,W
1222:  BSF    03.6
1223:  MOVWF  34
1224:  BCF    03.6
1225:  MOVF   32,W
1226:  BSF    03.6
1227:  MOVWF  33
1228:  BCF    03.6
1229:  MOVF   31,W
122A:  BSF    03.6
122B:  MOVWF  32
122C:  BCF    0A.4
122D:  BCF    03.6
122E:  CALL   6D6
122F:  BSF    0A.4
1230:  MOVF   79,W
1231:  MOVWF  55
1232:  MOVF   78,W
1233:  MOVWF  54
1234:  BSF    0A.3
1235:  BSF    0A.4
1236:  GOTO   58B (RETURN)
.................... }
.................... Void Alarm_Control()
.................... {
....................       // Bao chuong canh bao            
....................       if(temp  > ( high_temp+ deadband/10)) 
1237:  MOVF   38,W
1238:  BSF    03.6
1239:  MOVWF  39
123A:  BCF    03.6
123B:  MOVF   37,W
123C:  BSF    03.6
123D:  MOVWF  38
123E:  BCF    03.6
123F:  MOVF   36,W
1240:  BSF    03.6
1241:  MOVWF  37
1242:  BCF    03.6
1243:  MOVF   35,W
1244:  BSF    03.6
1245:  MOVWF  36
1246:  CLRF   3D
1247:  CLRF   3C
1248:  MOVLW  20
1249:  MOVWF  3B
124A:  MOVLW  82
124B:  MOVWF  3A
124C:  BCF    0A.4
124D:  BCF    03.6
124E:  CALL   40C
124F:  BSF    0A.4
1250:  MOVF   7A,W
1251:  BSF    03.6
1252:  MOVWF  35
1253:  MOVF   79,W
1254:  MOVWF  34
1255:  MOVF   78,W
1256:  MOVWF  33
1257:  MOVF   77,W
1258:  MOVWF  32
1259:  CLRF   37
125A:  BCF    03.6
125B:  MOVF   39,W
125C:  BSF    03.6
125D:  MOVWF  36
125E:  BTFSC  36.7
125F:  DECF   37,F
1260:  BCF    0A.4
1261:  BSF    0A.3
1262:  BCF    03.6
1263:  CALL   6FD
1264:  BSF    0A.4
1265:  BCF    0A.3
1266:  BCF    03.1
1267:  MOVF   7A,W
1268:  BSF    03.6
1269:  MOVWF  39
126A:  MOVF   79,W
126B:  MOVWF  38
126C:  MOVF   78,W
126D:  MOVWF  37
126E:  MOVF   77,W
126F:  MOVWF  36
1270:  MOVF   35,W
1271:  MOVWF  3D
1272:  MOVF   34,W
1273:  MOVWF  3C
1274:  MOVF   33,W
1275:  MOVWF  3B
1276:  MOVF   32,W
1277:  MOVWF  3A
1278:  BCF    0A.4
1279:  BCF    03.6
127A:  CALL   54F
127B:  BSF    0A.4
127C:  MOVF   7A,W
127D:  BSF    03.6
127E:  MOVWF  39
127F:  MOVF   79,W
1280:  MOVWF  38
1281:  MOVF   78,W
1282:  MOVWF  37
1283:  MOVF   77,W
1284:  MOVWF  36
1285:  MOVF   72,W
1286:  MOVWF  3D
1287:  MOVF   71,W
1288:  MOVWF  3C
1289:  MOVF   70,W
128A:  MOVWF  3B
128B:  BCF    03.6
128C:  MOVF   6F,W
128D:  BSF    03.6
128E:  MOVWF  3A
128F:  BCF    0A.4
1290:  BCF    03.6
1291:  CALL   695
1292:  BSF    0A.4
1293:  BTFSS  03.0
1294:  GOTO   297
....................          alarmbit[0]=1;             //canh bao muc cao  cua nhiet do
1295:  BSF    45.0
1296:  GOTO   2F5
....................       else if(temp < (high_temp- deadband/10)) 
1297:  MOVF   38,W
1298:  BSF    03.6
1299:  MOVWF  39
129A:  BCF    03.6
129B:  MOVF   37,W
129C:  BSF    03.6
129D:  MOVWF  38
129E:  BCF    03.6
129F:  MOVF   36,W
12A0:  BSF    03.6
12A1:  MOVWF  37
12A2:  BCF    03.6
12A3:  MOVF   35,W
12A4:  BSF    03.6
12A5:  MOVWF  36
12A6:  CLRF   3D
12A7:  CLRF   3C
12A8:  MOVLW  20
12A9:  MOVWF  3B
12AA:  MOVLW  82
12AB:  MOVWF  3A
12AC:  BCF    0A.4
12AD:  BCF    03.6
12AE:  CALL   40C
12AF:  BSF    0A.4
12B0:  MOVF   7A,W
12B1:  BSF    03.6
12B2:  MOVWF  35
12B3:  MOVF   79,W
12B4:  MOVWF  34
12B5:  MOVF   78,W
12B6:  MOVWF  33
12B7:  MOVF   77,W
12B8:  MOVWF  32
12B9:  CLRF   37
12BA:  BCF    03.6
12BB:  MOVF   39,W
12BC:  BSF    03.6
12BD:  MOVWF  36
12BE:  BTFSC  36.7
12BF:  DECF   37,F
12C0:  BCF    0A.4
12C1:  BSF    0A.3
12C2:  BCF    03.6
12C3:  CALL   6FD
12C4:  BSF    0A.4
12C5:  BCF    0A.3
12C6:  BSF    03.1
12C7:  MOVF   7A,W
12C8:  BSF    03.6
12C9:  MOVWF  39
12CA:  MOVF   79,W
12CB:  MOVWF  38
12CC:  MOVF   78,W
12CD:  MOVWF  37
12CE:  MOVF   77,W
12CF:  MOVWF  36
12D0:  MOVF   35,W
12D1:  MOVWF  3D
12D2:  MOVF   34,W
12D3:  MOVWF  3C
12D4:  MOVF   33,W
12D5:  MOVWF  3B
12D6:  MOVF   32,W
12D7:  MOVWF  3A
12D8:  BCF    0A.4
12D9:  BCF    03.6
12DA:  CALL   54F
12DB:  BSF    0A.4
12DC:  MOVF   72,W
12DD:  BSF    03.6
12DE:  MOVWF  39
12DF:  MOVF   71,W
12E0:  MOVWF  38
12E1:  MOVF   70,W
12E2:  MOVWF  37
12E3:  BCF    03.6
12E4:  MOVF   6F,W
12E5:  BSF    03.6
12E6:  MOVWF  36
12E7:  MOVF   7A,W
12E8:  MOVWF  3D
12E9:  MOVF   79,W
12EA:  MOVWF  3C
12EB:  MOVF   78,W
12EC:  MOVWF  3B
12ED:  MOVF   77,W
12EE:  MOVWF  3A
12EF:  BCF    0A.4
12F0:  BCF    03.6
12F1:  CALL   695
12F2:  BSF    0A.4
12F3:  BTFSC  03.0
....................          alarmbit[0]=0;
12F4:  BCF    45.0
....................       if(temp < (low_temp - deadband/10))
12F5:  MOVF   38,W
12F6:  BSF    03.6
12F7:  MOVWF  39
12F8:  BCF    03.6
12F9:  MOVF   37,W
12FA:  BSF    03.6
12FB:  MOVWF  38
12FC:  BCF    03.6
12FD:  MOVF   36,W
12FE:  BSF    03.6
12FF:  MOVWF  37
1300:  BCF    03.6
1301:  MOVF   35,W
1302:  BSF    03.6
1303:  MOVWF  36
1304:  CLRF   3D
1305:  CLRF   3C
1306:  MOVLW  20
1307:  MOVWF  3B
1308:  MOVLW  82
1309:  MOVWF  3A
130A:  BCF    0A.4
130B:  BCF    03.6
130C:  CALL   40C
130D:  BSF    0A.4
130E:  MOVF   7A,W
130F:  BSF    03.6
1310:  MOVWF  35
1311:  MOVF   79,W
1312:  MOVWF  34
1313:  MOVF   78,W
1314:  MOVWF  33
1315:  MOVF   77,W
1316:  MOVWF  32
1317:  CLRF   37
1318:  BCF    03.6
1319:  MOVF   3A,W
131A:  BSF    03.6
131B:  MOVWF  36
131C:  BTFSC  36.7
131D:  DECF   37,F
131E:  BCF    0A.4
131F:  BSF    0A.3
1320:  BCF    03.6
1321:  CALL   6FD
1322:  BSF    0A.4
1323:  BCF    0A.3
1324:  BSF    03.1
1325:  MOVF   7A,W
1326:  BSF    03.6
1327:  MOVWF  39
1328:  MOVF   79,W
1329:  MOVWF  38
132A:  MOVF   78,W
132B:  MOVWF  37
132C:  MOVF   77,W
132D:  MOVWF  36
132E:  MOVF   35,W
132F:  MOVWF  3D
1330:  MOVF   34,W
1331:  MOVWF  3C
1332:  MOVF   33,W
1333:  MOVWF  3B
1334:  MOVF   32,W
1335:  MOVWF  3A
1336:  BCF    0A.4
1337:  BCF    03.6
1338:  CALL   54F
1339:  BSF    0A.4
133A:  MOVF   72,W
133B:  BSF    03.6
133C:  MOVWF  39
133D:  MOVF   71,W
133E:  MOVWF  38
133F:  MOVF   70,W
1340:  MOVWF  37
1341:  BCF    03.6
1342:  MOVF   6F,W
1343:  BSF    03.6
1344:  MOVWF  36
1345:  MOVF   7A,W
1346:  MOVWF  3D
1347:  MOVF   79,W
1348:  MOVWF  3C
1349:  MOVF   78,W
134A:  MOVWF  3B
134B:  MOVF   77,W
134C:  MOVWF  3A
134D:  BCF    0A.4
134E:  BCF    03.6
134F:  CALL   695
1350:  BSF    0A.4
1351:  BTFSS  03.0
1352:  GOTO   355
....................          alarmbit[1]=1;            //// canh bao muc thap cua nhiet do      
1353:  BSF    45.1
1354:  GOTO   3B3
....................       else if(temp > (low_temp + deadband/10))
1355:  MOVF   38,W
1356:  BSF    03.6
1357:  MOVWF  39
1358:  BCF    03.6
1359:  MOVF   37,W
135A:  BSF    03.6
135B:  MOVWF  38
135C:  BCF    03.6
135D:  MOVF   36,W
135E:  BSF    03.6
135F:  MOVWF  37
1360:  BCF    03.6
1361:  MOVF   35,W
1362:  BSF    03.6
1363:  MOVWF  36
1364:  CLRF   3D
1365:  CLRF   3C
1366:  MOVLW  20
1367:  MOVWF  3B
1368:  MOVLW  82
1369:  MOVWF  3A
136A:  BCF    0A.4
136B:  BCF    03.6
136C:  CALL   40C
136D:  BSF    0A.4
136E:  MOVF   7A,W
136F:  BSF    03.6
1370:  MOVWF  35
1371:  MOVF   79,W
1372:  MOVWF  34
1373:  MOVF   78,W
1374:  MOVWF  33
1375:  MOVF   77,W
1376:  MOVWF  32
1377:  CLRF   37
1378:  BCF    03.6
1379:  MOVF   3A,W
137A:  BSF    03.6
137B:  MOVWF  36
137C:  BTFSC  36.7
137D:  DECF   37,F
137E:  BCF    0A.4
137F:  BSF    0A.3
1380:  BCF    03.6
1381:  CALL   6FD
1382:  BSF    0A.4
1383:  BCF    0A.3
1384:  BCF    03.1
1385:  MOVF   7A,W
1386:  BSF    03.6
1387:  MOVWF  39
1388:  MOVF   79,W
1389:  MOVWF  38
138A:  MOVF   78,W
138B:  MOVWF  37
138C:  MOVF   77,W
138D:  MOVWF  36
138E:  MOVF   35,W
138F:  MOVWF  3D
1390:  MOVF   34,W
1391:  MOVWF  3C
1392:  MOVF   33,W
1393:  MOVWF  3B
1394:  MOVF   32,W
1395:  MOVWF  3A
1396:  BCF    0A.4
1397:  BCF    03.6
1398:  CALL   54F
1399:  BSF    0A.4
139A:  MOVF   7A,W
139B:  BSF    03.6
139C:  MOVWF  39
139D:  MOVF   79,W
139E:  MOVWF  38
139F:  MOVF   78,W
13A0:  MOVWF  37
13A1:  MOVF   77,W
13A2:  MOVWF  36
13A3:  MOVF   72,W
13A4:  MOVWF  3D
13A5:  MOVF   71,W
13A6:  MOVWF  3C
13A7:  MOVF   70,W
13A8:  MOVWF  3B
13A9:  BCF    03.6
13AA:  MOVF   6F,W
13AB:  BSF    03.6
13AC:  MOVWF  3A
13AD:  BCF    0A.4
13AE:  BCF    03.6
13AF:  CALL   695
13B0:  BSF    0A.4
13B1:  BTFSC  03.0
....................          alarmbit[1]=0;
13B2:  BCF    45.1
....................       
....................       Canhbao=alarmbit[0]+alarmbit[1];
13B3:  MOVLW  00
13B4:  BTFSC  45.0
13B5:  MOVLW  01
13B6:  BSF    03.6
13B7:  MOVWF  33
13B8:  MOVLW  00
13B9:  BCF    03.6
13BA:  BTFSC  45.1
13BB:  MOVLW  01
13BC:  BSF    03.6
13BD:  ADDWF  33,W
13BE:  BCF    03.6
13BF:  MOVWF  2E
....................       //Alarm ACK
....................       if((input(pin_D5)==0)&&(input(pin_D6)==1)&&(Old_Alarm==0))
13C0:  BTFSC  08.5
13C1:  GOTO   3D4
13C2:  BTFSS  08.6
13C3:  GOTO   3D4
13C4:  BTFSC  2A.4
13C5:  GOTO   3D4
....................       {
....................          delay_ms(5);
13C6:  MOVLW  05
13C7:  BSF    03.6
13C8:  MOVWF  3F
13C9:  BCF    0A.4
13CA:  BCF    03.6
13CB:  CALL   791
13CC:  BSF    0A.4
....................          if((input(pin_D5)==0)&&(input(pin_D6)==1)&&(Old_Alarm==0))
13CD:  BTFSC  08.5
13CE:  GOTO   3D3
13CF:  BTFSS  08.6
13D0:  GOTO   3D3
13D1:  BTFSS  2A.4
....................          {
....................             Old_Alarm=1;
13D2:  BSF    2A.4
....................          }
....................       }
13D3:  GOTO   3DC
....................       else if((input(pin_D5)==1)&&(input(pin_D6)==1)&&(Old_Alarm==1))
13D4:  BTFSS  08.5
13D5:  GOTO   3DC
13D6:  BTFSS  08.6
13D7:  GOTO   3DC
13D8:  BTFSS  2A.4
13D9:  GOTO   3DC
....................       {
....................          alarmACK=1;
13DA:  BSF    2A.5
....................          Old_Alarm=0;
13DB:  BCF    2A.4
....................       }
....................    //Control horn temp
....................    if(Read_ok==1)
13DC:  BTFSS  47.1
13DD:  GOTO   413
....................    {
....................       if((canhbao>0) && (alarmACK==0)&&(read_ok==1))
13DE:  MOVF   2E,F
13DF:  BTFSC  03.2
13E0:  GOTO   3F5
13E1:  BTFSC  2A.5
13E2:  GOTO   3F5
13E3:  BTFSS  47.1
13E4:  GOTO   3F5
....................       {
....................          output_high(pin_D0);
13E5:  BSF    08.0
....................          if(nhapnhay >= 1)
13E6:  MOVF   3B,W
13E7:  SUBLW  00
13E8:  BTFSC  03.0
13E9:  GOTO   3EC
....................          {
....................             nhapnhay=0;                  
13EA:  CLRF   3B
....................          }
13EB:  GOTO   3ED
....................          else
....................          {
....................             nhapnhay++;
13EC:  INCF   3B,F
....................          }
....................          
....................          if(nhapnhay >= 1)
13ED:  MOVF   3B,W
13EE:  SUBLW  00
13EF:  BTFSC  03.0
13F0:  GOTO   3F3
....................          {
....................             Led_Alarm=1;
13F1:  BSF    2A.7
....................          }
13F2:  GOTO   3F4
....................          else
....................          {
....................             Led_Alarm=0;
13F3:  BCF    2A.7
....................          }
....................       }
13F4:  GOTO   412
....................       else if((canhbao>0) && (alarmACK==1)&&(read_ok==1))
13F5:  MOVF   2E,F
13F6:  BTFSC  03.2
13F7:  GOTO   40C
13F8:  BTFSS  2A.5
13F9:  GOTO   40C
13FA:  BTFSS  47.1
13FB:  GOTO   40C
....................       {
....................          output_low(pin_D0);
13FC:  BCF    08.0
....................          if(nhapnhay >= 10)
13FD:  MOVF   3B,W
13FE:  SUBLW  09
13FF:  BTFSC  03.0
1400:  GOTO   403
....................          {
....................             nhapnhay=0;                  
1401:  CLRF   3B
....................          }
1402:  GOTO   40B
....................          else
....................          {
....................             nhapnhay++;
1403:  INCF   3B,F
....................             if(nhapnhay >= 5)
1404:  MOVF   3B,W
1405:  SUBLW  04
1406:  BTFSC  03.0
1407:  GOTO   40A
....................             {
....................                Led_Alarm=1;
1408:  BSF    2A.7
....................             }
1409:  GOTO   40B
....................             else
....................             {
....................                Led_Alarm=0;
140A:  BCF    2A.7
....................             }
....................          }
....................       }
140B:  GOTO   412
....................       else if(canhbao==0)
140C:  MOVF   2E,F
140D:  BTFSS  03.2
140E:  GOTO   412
....................       {
....................          alarmACK=0;
140F:  BCF    2A.5
....................          Led_Alarm=0;
1410:  BCF    2A.7
....................          output_low(pin_D0);
1411:  BCF    08.0
....................       } 
....................    }
1412:  GOTO   416
....................    else
....................    {
....................       alarmACK=0;
1413:  BCF    2A.5
....................       Led_Alarm=0;
1414:  BCF    2A.7
....................       output_high(pin_D0);   
1415:  BSF    08.0
....................    }
1416:  BSF    0A.3
1417:  BSF    0A.4
1418:  GOTO   79B (RETURN)
.................... }
.................... Void Nutnhan()
.................... {
....................    //Cofig chinh nhiet do bao chuong
....................    if((input(pin_D7)==0)&&(Old_Mode==0))
*
0FB7:  BTFSC  08.7
0FB8:  GOTO   7C7
0FB9:  BTFSC  2A.3
0FBA:  GOTO   7C7
....................    {
....................       delay_ms(10);
0FBB:  MOVLW  0A
0FBC:  BSF    03.6
0FBD:  MOVWF  3F
0FBE:  BCF    0A.3
0FBF:  BCF    03.6
0FC0:  CALL   791
0FC1:  BSF    0A.3
....................       if((input(pin_D7)==0)&&(Old_Mode==0))
0FC2:  BTFSC  08.7
0FC3:  GOTO   7C6
0FC4:  BTFSS  2A.3
....................       {            
....................          Old_Mode=1;
0FC5:  BSF    2A.3
....................       }
....................    }
0FC6:  GOTO   7CF
....................    else if((input(pin_D7)==1)&&(Old_Mode==1))
0FC7:  BTFSS  08.7
0FC8:  GOTO   7CF
0FC9:  BTFSS  2A.3
0FCA:  GOTO   7CF
....................    {
....................       Config=1;
0FCB:  MOVLW  01
0FCC:  MOVWF  30
....................       Set_count=1;
0FCD:  MOVWF  2F
....................       Old_Mode=0;
0FCE:  BCF    2A.3
....................    } 
0FCF:  BSF    0A.3
0FD0:  BSF    0A.4
0FD1:  GOTO   79E (RETURN)
.................... }
.................... Void CaiDat()
.................... {
....................    Led_Alarm=0;
*
1800:  BCF    2A.7
....................    Modbus_update=0;
1801:  BCF    2A.1
....................    Canhbao=0;
1802:  CLRF   2E
....................    alarmbit[0]=0;
1803:  BCF    45.0
....................    alarmbit[1]=0;
1804:  BCF    45.1
....................    alarmACK=0;
1805:  BCF    2A.5
....................    Count_ReadTemp=0;
1806:  BCF    2A.6
....................    output_low(pin_D0);   
1807:  BCF    08.0
....................    if(set_count ==1)
1808:  DECFSZ 2F,W
1809:  GOTO   0A7
....................    {
....................       Daucham=0;
180A:  BCF    2A.0
....................       if(high_temp>=0)
180B:  BTFSC  39.7
180C:  GOTO   076
....................       {
....................          temp_array[0]= 17;//H
180D:  MOVLW  11
180E:  MOVWF  41
....................          temp_array[1]= (int8)high_temp/100 ;
180F:  MOVF   39,W
1810:  BSF    03.6
1811:  MOVWF  33
1812:  MOVLW  64
1813:  MOVWF  34
1814:  BCF    0A.4
1815:  BCF    0A.3
1816:  BCF    03.6
1817:  CALL   6F7
1818:  BSF    0A.4
1819:  BSF    0A.3
181A:  MOVF   78,W
181B:  MOVWF  42
....................          temp = (int8)high_temp%100;
181C:  MOVF   39,W
181D:  BSF    03.6
181E:  MOVWF  33
181F:  MOVLW  64
1820:  MOVWF  34
1821:  BCF    0A.4
1822:  BCF    0A.3
1823:  BCF    03.6
1824:  CALL   6F7
1825:  BSF    0A.4
1826:  BSF    0A.3
1827:  MOVF   77,W
1828:  BSF    03.6
1829:  CLRF   33
182A:  MOVWF  32
182B:  BCF    0A.4
182C:  BCF    0A.3
182D:  BCF    03.6
182E:  CALL   3ED
182F:  BSF    0A.4
1830:  BSF    0A.3
1831:  MOVF   7A,W
1832:  MOVWF  72
1833:  MOVF   79,W
1834:  MOVWF  71
1835:  MOVF   78,W
1836:  MOVWF  70
1837:  MOVF   77,W
1838:  MOVWF  6F
....................          temp_array[2]= (int8)temp/10;
1839:  MOVF   72,W
183A:  BSF    03.6
183B:  MOVWF  35
183C:  MOVF   71,W
183D:  MOVWF  34
183E:  MOVF   70,W
183F:  MOVWF  33
1840:  BCF    03.6
1841:  MOVF   6F,W
1842:  BSF    03.6
1843:  MOVWF  32
1844:  BCF    0A.4
1845:  BCF    0A.3
1846:  BCF    03.6
1847:  CALL   6D6
1848:  BSF    0A.4
1849:  BSF    0A.3
184A:  MOVF   78,W
184B:  BSF    03.6
184C:  MOVWF  33
184D:  MOVLW  0A
184E:  MOVWF  34
184F:  BCF    0A.4
1850:  BCF    0A.3
1851:  BCF    03.6
1852:  CALL   6F7
1853:  BSF    0A.4
1854:  BSF    0A.3
1855:  MOVF   78,W
1856:  MOVWF  43
....................          temp_array[3]= (int8)temp%10;  
1857:  MOVF   72,W
1858:  BSF    03.6
1859:  MOVWF  35
185A:  MOVF   71,W
185B:  MOVWF  34
185C:  MOVF   70,W
185D:  MOVWF  33
185E:  BCF    03.6
185F:  MOVF   6F,W
1860:  BSF    03.6
1861:  MOVWF  32
1862:  BCF    0A.4
1863:  BCF    0A.3
1864:  BCF    03.6
1865:  CALL   6D6
1866:  BSF    0A.4
1867:  BSF    0A.3
1868:  MOVF   78,W
1869:  BSF    03.6
186A:  MOVWF  33
186B:  MOVLW  0A
186C:  MOVWF  34
186D:  BCF    0A.4
186E:  BCF    0A.3
186F:  BCF    03.6
1870:  CALL   6F7
1871:  BSF    0A.4
1872:  BSF    0A.3
1873:  MOVF   77,W
1874:  MOVWF  44
....................       }
1875:  GOTO   0A6
....................       else
....................       {
....................          temp_array[0]= 17;//H
1876:  MOVLW  11
1877:  MOVWF  41
....................          temp_array[1]= 10;
1878:  MOVLW  0A
1879:  MOVWF  42
....................          temp_array[2]= (int8)(high_temp*(-1))/10 ;              
187A:  MOVF   39,W
187B:  BSF    03.6
187C:  MOVWF  33
187D:  MOVLW  FF
187E:  MOVWF  34
187F:  BCF    0A.4
1880:  BCF    0A.3
1881:  BCF    03.6
1882:  CALL   7C8
1883:  BSF    0A.4
1884:  BSF    0A.3
1885:  MOVF   78,W
1886:  BSF    03.6
1887:  MOVWF  33
1888:  MOVLW  0A
1889:  MOVWF  34
188A:  BCF    0A.4
188B:  BCF    03.6
188C:  CALL   7D2
188D:  BSF    0A.4
188E:  MOVF   78,W
188F:  MOVWF  43
....................          temp_array[3]= (int8)(high_temp*(-1))%10 ;              
1890:  MOVF   39,W
1891:  BSF    03.6
1892:  MOVWF  33
1893:  MOVLW  FF
1894:  MOVWF  34
1895:  BCF    0A.4
1896:  BCF    0A.3
1897:  BCF    03.6
1898:  CALL   7C8
1899:  BSF    0A.4
189A:  BSF    0A.3
189B:  MOVF   78,W
189C:  BSF    03.6
189D:  MOVWF  33
189E:  MOVLW  0A
189F:  MOVWF  34
18A0:  BCF    0A.4
18A1:  BCF    03.6
18A2:  CALL   7D2
18A3:  BSF    0A.4
18A4:  MOVF   77,W
18A5:  MOVWF  44
....................       }
....................    } 
18A6:  GOTO   27E
....................    else if(set_count ==2)
18A7:  MOVF   2F,W
18A8:  SUBLW  02
18A9:  BTFSS  03.2
18AA:  GOTO   148
....................    {
....................       Daucham=0;
18AB:  BCF    2A.0
....................       if(low_temp>=0)
18AC:  BTFSC  3A.7
18AD:  GOTO   117
....................       {
....................          temp_array[0]= 18;//L
18AE:  MOVLW  12
18AF:  MOVWF  41
....................          temp_array[1]= (int8)low_temp/100 ;
18B0:  MOVF   3A,W
18B1:  BSF    03.6
18B2:  MOVWF  33
18B3:  MOVLW  64
18B4:  MOVWF  34
18B5:  BCF    0A.4
18B6:  BCF    0A.3
18B7:  BCF    03.6
18B8:  CALL   6F7
18B9:  BSF    0A.4
18BA:  BSF    0A.3
18BB:  MOVF   78,W
18BC:  MOVWF  42
....................          temp = (int8)low_temp%100;
18BD:  MOVF   3A,W
18BE:  BSF    03.6
18BF:  MOVWF  33
18C0:  MOVLW  64
18C1:  MOVWF  34
18C2:  BCF    0A.4
18C3:  BCF    0A.3
18C4:  BCF    03.6
18C5:  CALL   6F7
18C6:  BSF    0A.4
18C7:  BSF    0A.3
18C8:  MOVF   77,W
18C9:  BSF    03.6
18CA:  CLRF   33
18CB:  MOVWF  32
18CC:  BCF    0A.4
18CD:  BCF    0A.3
18CE:  BCF    03.6
18CF:  CALL   3ED
18D0:  BSF    0A.4
18D1:  BSF    0A.3
18D2:  MOVF   7A,W
18D3:  MOVWF  72
18D4:  MOVF   79,W
18D5:  MOVWF  71
18D6:  MOVF   78,W
18D7:  MOVWF  70
18D8:  MOVF   77,W
18D9:  MOVWF  6F
....................          temp_array[2]= (int8)temp/10;
18DA:  MOVF   72,W
18DB:  BSF    03.6
18DC:  MOVWF  35
18DD:  MOVF   71,W
18DE:  MOVWF  34
18DF:  MOVF   70,W
18E0:  MOVWF  33
18E1:  BCF    03.6
18E2:  MOVF   6F,W
18E3:  BSF    03.6
18E4:  MOVWF  32
18E5:  BCF    0A.4
18E6:  BCF    0A.3
18E7:  BCF    03.6
18E8:  CALL   6D6
18E9:  BSF    0A.4
18EA:  BSF    0A.3
18EB:  MOVF   78,W
18EC:  BSF    03.6
18ED:  MOVWF  33
18EE:  MOVLW  0A
18EF:  MOVWF  34
18F0:  BCF    0A.4
18F1:  BCF    0A.3
18F2:  BCF    03.6
18F3:  CALL   6F7
18F4:  BSF    0A.4
18F5:  BSF    0A.3
18F6:  MOVF   78,W
18F7:  MOVWF  43
....................          temp_array[3]= (int8)temp%10;  
18F8:  MOVF   72,W
18F9:  BSF    03.6
18FA:  MOVWF  35
18FB:  MOVF   71,W
18FC:  MOVWF  34
18FD:  MOVF   70,W
18FE:  MOVWF  33
18FF:  BCF    03.6
1900:  MOVF   6F,W
1901:  BSF    03.6
1902:  MOVWF  32
1903:  BCF    0A.4
1904:  BCF    0A.3
1905:  BCF    03.6
1906:  CALL   6D6
1907:  BSF    0A.4
1908:  BSF    0A.3
1909:  MOVF   78,W
190A:  BSF    03.6
190B:  MOVWF  33
190C:  MOVLW  0A
190D:  MOVWF  34
190E:  BCF    0A.4
190F:  BCF    0A.3
1910:  BCF    03.6
1911:  CALL   6F7
1912:  BSF    0A.4
1913:  BSF    0A.3
1914:  MOVF   77,W
1915:  MOVWF  44
....................       }
1916:  GOTO   147
....................       else
....................       {
....................          temp_array[0]= 18;//L
1917:  MOVLW  12
1918:  MOVWF  41
....................          temp_array[1]= 10;
1919:  MOVLW  0A
191A:  MOVWF  42
....................          temp_array[2]= (int8)(low_temp*(-1))/10 ;              
191B:  MOVF   3A,W
191C:  BSF    03.6
191D:  MOVWF  33
191E:  MOVLW  FF
191F:  MOVWF  34
1920:  BCF    0A.4
1921:  BCF    0A.3
1922:  BCF    03.6
1923:  CALL   7C8
1924:  BSF    0A.4
1925:  BSF    0A.3
1926:  MOVF   78,W
1927:  BSF    03.6
1928:  MOVWF  33
1929:  MOVLW  0A
192A:  MOVWF  34
192B:  BCF    0A.4
192C:  BCF    03.6
192D:  CALL   7D2
192E:  BSF    0A.4
192F:  MOVF   78,W
1930:  MOVWF  43
....................          temp_array[3]= (int8)(low_temp*(-1))%10 ;              
1931:  MOVF   3A,W
1932:  BSF    03.6
1933:  MOVWF  33
1934:  MOVLW  FF
1935:  MOVWF  34
1936:  BCF    0A.4
1937:  BCF    0A.3
1938:  BCF    03.6
1939:  CALL   7C8
193A:  BSF    0A.4
193B:  BSF    0A.3
193C:  MOVF   78,W
193D:  BSF    03.6
193E:  MOVWF  33
193F:  MOVLW  0A
1940:  MOVWF  34
1941:  BCF    0A.4
1942:  BCF    03.6
1943:  CALL   7D2
1944:  BSF    0A.4
1945:  MOVF   77,W
1946:  MOVWF  44
....................       }
....................    }
1947:  GOTO   27E
....................    else if(set_count ==3)
1948:  MOVF   2F,W
1949:  SUBLW  03
194A:  BTFSS  03.2
194B:  GOTO   196
....................    {
....................       Daucham=1;
194C:  BSF    2A.0
....................       temp_array[0]= 19;//b
194D:  MOVLW  13
194E:  MOVWF  41
....................       temp_array[1]= 20;//b
194F:  MOVLW  14
1950:  MOVWF  42
....................       temp_array[2]= (int8)deadband/10;
1951:  MOVF   38,W
1952:  BSF    03.6
1953:  MOVWF  35
1954:  BCF    03.6
1955:  MOVF   37,W
1956:  BSF    03.6
1957:  MOVWF  34
1958:  BCF    03.6
1959:  MOVF   36,W
195A:  BSF    03.6
195B:  MOVWF  33
195C:  BCF    03.6
195D:  MOVF   35,W
195E:  BSF    03.6
195F:  MOVWF  32
1960:  BCF    0A.4
1961:  BCF    0A.3
1962:  BCF    03.6
1963:  CALL   6D6
1964:  BSF    0A.4
1965:  BSF    0A.3
1966:  MOVF   78,W
1967:  BSF    03.6
1968:  MOVWF  33
1969:  MOVLW  0A
196A:  MOVWF  34
196B:  BCF    0A.4
196C:  BCF    0A.3
196D:  BCF    03.6
196E:  CALL   6F7
196F:  BSF    0A.4
1970:  BSF    0A.3
1971:  MOVF   78,W
1972:  MOVWF  43
....................       temp_array[3]= (int8)deadband%10;      
1973:  MOVF   38,W
1974:  BSF    03.6
1975:  MOVWF  35
1976:  BCF    03.6
1977:  MOVF   37,W
1978:  BSF    03.6
1979:  MOVWF  34
197A:  BCF    03.6
197B:  MOVF   36,W
197C:  BSF    03.6
197D:  MOVWF  33
197E:  BCF    03.6
197F:  MOVF   35,W
1980:  BSF    03.6
1981:  MOVWF  32
1982:  BCF    0A.4
1983:  BCF    0A.3
1984:  BCF    03.6
1985:  CALL   6D6
1986:  BSF    0A.4
1987:  BSF    0A.3
1988:  MOVF   78,W
1989:  BSF    03.6
198A:  MOVWF  33
198B:  MOVLW  0A
198C:  MOVWF  34
198D:  BCF    0A.4
198E:  BCF    0A.3
198F:  BCF    03.6
1990:  CALL   6F7
1991:  BSF    0A.4
1992:  BSF    0A.3
1993:  MOVF   77,W
1994:  MOVWF  44
....................    }         
1995:  GOTO   27E
....................    else if(set_count ==4)
1996:  MOVF   2F,W
1997:  SUBLW  04
1998:  BTFSS  03.2
1999:  GOTO   27E
....................    {
....................       Daucham=1;
199A:  BSF    2A.0
....................       if(temp_offset < 0)
199B:  MOVF   34,W
199C:  BSF    03.6
199D:  MOVWF  39
199E:  BCF    03.6
199F:  MOVF   33,W
19A0:  BSF    03.6
19A1:  MOVWF  38
19A2:  BCF    03.6
19A3:  MOVF   32,W
19A4:  BSF    03.6
19A5:  MOVWF  37
19A6:  BCF    03.6
19A7:  MOVF   31,W
19A8:  BSF    03.6
19A9:  MOVWF  36
19AA:  CLRF   3D
19AB:  CLRF   3C
19AC:  CLRF   3B
19AD:  CLRF   3A
19AE:  BCF    0A.4
19AF:  BCF    0A.3
19B0:  BCF    03.6
19B1:  CALL   695
19B2:  BSF    0A.4
19B3:  BSF    0A.3
19B4:  BTFSS  03.0
19B5:  GOTO   229
....................       {
....................          temp_array[0]=21;//C
19B6:  MOVLW  15
19B7:  MOVWF  41
....................          temp_array[1]=10;
19B8:  MOVLW  0A
19B9:  MOVWF  42
....................          temp_array[2]=(int8)(temp_offset*(-1))/10;
19BA:  MOVF   34,W
19BB:  BSF    03.6
19BC:  MOVWF  35
19BD:  BCF    03.6
19BE:  MOVF   33,W
19BF:  BSF    03.6
19C0:  MOVWF  34
19C1:  BCF    03.6
19C2:  MOVF   32,W
19C3:  BSF    03.6
19C4:  MOVWF  33
19C5:  BCF    03.6
19C6:  MOVF   31,W
19C7:  BSF    03.6
19C8:  MOVWF  32
19C9:  CLRF   39
19CA:  CLRF   38
19CB:  MOVLW  80
19CC:  MOVWF  37
19CD:  MOVLW  7F
19CE:  MOVWF  36
19CF:  BCF    0A.4
19D0:  BCF    0A.3
19D1:  BCF    03.6
19D2:  CALL   4D8
19D3:  BSF    0A.4
19D4:  BSF    0A.3
19D5:  MOVF   7A,W
19D6:  BSF    03.6
19D7:  MOVWF  35
19D8:  MOVF   79,W
19D9:  MOVWF  34
19DA:  MOVF   78,W
19DB:  MOVWF  33
19DC:  MOVF   77,W
19DD:  MOVWF  32
19DE:  BCF    0A.4
19DF:  BCF    0A.3
19E0:  BCF    03.6
19E1:  CALL   6D6
19E2:  BSF    0A.4
19E3:  BSF    0A.3
19E4:  MOVF   78,W
19E5:  BSF    03.6
19E6:  MOVWF  33
19E7:  MOVLW  0A
19E8:  MOVWF  34
19E9:  BCF    0A.4
19EA:  BCF    0A.3
19EB:  BCF    03.6
19EC:  CALL   6F7
19ED:  BSF    0A.4
19EE:  BSF    0A.3
19EF:  MOVF   78,W
19F0:  MOVWF  43
....................          temp_array[3]=(int8)(temp_offset*(-1))%10;         
19F1:  MOVF   34,W
19F2:  BSF    03.6
19F3:  MOVWF  35
19F4:  BCF    03.6
19F5:  MOVF   33,W
19F6:  BSF    03.6
19F7:  MOVWF  34
19F8:  BCF    03.6
19F9:  MOVF   32,W
19FA:  BSF    03.6
19FB:  MOVWF  33
19FC:  BCF    03.6
19FD:  MOVF   31,W
19FE:  BSF    03.6
19FF:  MOVWF  32
1A00:  CLRF   39
1A01:  CLRF   38
1A02:  MOVLW  80
1A03:  MOVWF  37
1A04:  MOVLW  7F
1A05:  MOVWF  36
1A06:  BCF    0A.4
1A07:  BCF    0A.3
1A08:  BCF    03.6
1A09:  CALL   4D8
1A0A:  BSF    0A.4
1A0B:  BSF    0A.3
1A0C:  MOVF   7A,W
1A0D:  BSF    03.6
1A0E:  MOVWF  35
1A0F:  MOVF   79,W
1A10:  MOVWF  34
1A11:  MOVF   78,W
1A12:  MOVWF  33
1A13:  MOVF   77,W
1A14:  MOVWF  32
1A15:  BCF    0A.4
1A16:  BCF    0A.3
1A17:  BCF    03.6
1A18:  CALL   6D6
1A19:  BSF    0A.4
1A1A:  BSF    0A.3
1A1B:  MOVF   78,W
1A1C:  BSF    03.6
1A1D:  MOVWF  33
1A1E:  MOVLW  0A
1A1F:  MOVWF  34
1A20:  BCF    0A.4
1A21:  BCF    0A.3
1A22:  BCF    03.6
1A23:  CALL   6F7
1A24:  BSF    0A.4
1A25:  BSF    0A.3
1A26:  MOVF   77,W
1A27:  MOVWF  44
....................       }
1A28:  GOTO   271
....................       else
....................       {
....................          temp_array[0]=21;//C
1A29:  MOVLW  15
1A2A:  MOVWF  41
....................          temp_array[1]=11;
1A2B:  MOVLW  0B
1A2C:  MOVWF  42
....................          temp_array[2]=(int8)temp_offset/10;
1A2D:  MOVF   34,W
1A2E:  BSF    03.6
1A2F:  MOVWF  35
1A30:  BCF    03.6
1A31:  MOVF   33,W
1A32:  BSF    03.6
1A33:  MOVWF  34
1A34:  BCF    03.6
1A35:  MOVF   32,W
1A36:  BSF    03.6
1A37:  MOVWF  33
1A38:  BCF    03.6
1A39:  MOVF   31,W
1A3A:  BSF    03.6
1A3B:  MOVWF  32
1A3C:  BCF    0A.4
1A3D:  BCF    0A.3
1A3E:  BCF    03.6
1A3F:  CALL   6D6
1A40:  BSF    0A.4
1A41:  BSF    0A.3
1A42:  MOVF   78,W
1A43:  BSF    03.6
1A44:  MOVWF  33
1A45:  MOVLW  0A
1A46:  MOVWF  34
1A47:  BCF    0A.4
1A48:  BCF    0A.3
1A49:  BCF    03.6
1A4A:  CALL   6F7
1A4B:  BSF    0A.4
1A4C:  BSF    0A.3
1A4D:  MOVF   78,W
1A4E:  MOVWF  43
....................          temp_array[3]=(int8)temp_offset%10;
1A4F:  MOVF   34,W
1A50:  BSF    03.6
1A51:  MOVWF  35
1A52:  BCF    03.6
1A53:  MOVF   33,W
1A54:  BSF    03.6
1A55:  MOVWF  34
1A56:  BCF    03.6
1A57:  MOVF   32,W
1A58:  BSF    03.6
1A59:  MOVWF  33
1A5A:  BCF    03.6
1A5B:  MOVF   31,W
1A5C:  BSF    03.6
1A5D:  MOVWF  32
1A5E:  BCF    0A.4
1A5F:  BCF    0A.3
1A60:  BCF    03.6
1A61:  CALL   6D6
1A62:  BSF    0A.4
1A63:  BSF    0A.3
1A64:  MOVF   78,W
1A65:  BSF    03.6
1A66:  MOVWF  33
1A67:  MOVLW  0A
1A68:  MOVWF  34
1A69:  BCF    0A.4
1A6A:  BCF    0A.3
1A6B:  BCF    03.6
1A6C:  CALL   6F7
1A6D:  BSF    0A.4
1A6E:  BSF    0A.3
1A6F:  MOVF   77,W
1A70:  MOVWF  44
....................       }
....................       display(temp_array,MAXNUM, control_array);// hien thi ra led 7 doan 
1A71:  BSF    03.6
1A72:  CLRF   33
1A73:  MOVLW  41
1A74:  MOVWF  32
1A75:  MOVLW  04
1A76:  MOVWF  34
1A77:  CLRF   36
1A78:  MOVLW  2B
1A79:  MOVWF  35
1A7A:  BCF    0A.4
1A7B:  BCF    03.6
1A7C:  CALL   5E3
1A7D:  BSF    0A.4
....................    }      
.................... 
....................    //Cong
....................    if(input(pin_D6)==0)
1A7E:  BTFSC  08.6
1A7F:  GOTO   352
....................    {
....................       delay_ms(50);
1A80:  MOVLW  32
1A81:  BSF    03.6
1A82:  MOVWF  3F
1A83:  BCF    0A.4
1A84:  BCF    0A.3
1A85:  BCF    03.6
1A86:  CALL   791
1A87:  BSF    0A.4
1A88:  BSF    0A.3
....................       if(input(pin_D6)==0)
1A89:  BTFSC  08.6
1A8A:  GOTO   351
....................       {
....................          delay_ms(50);
1A8B:  MOVLW  32
1A8C:  BSF    03.6
1A8D:  MOVWF  3F
1A8E:  BCF    0A.4
1A8F:  BCF    0A.3
1A90:  BCF    03.6
1A91:  CALL   791
1A92:  BSF    0A.4
1A93:  BSF    0A.3
....................          if(set_count==1)
1A94:  DECFSZ 2F,W
1A95:  GOTO   2A2
....................          {
....................             if(high_temp >= 125)
1A96:  BTFSC  39.7
1A97:  GOTO   29F
1A98:  MOVF   39,W
1A99:  SUBLW  7C
1A9A:  BTFSC  03.0
1A9B:  GOTO   29F
....................             {
....................                high_temp =125;
1A9C:  MOVLW  7D
1A9D:  MOVWF  39
....................             }
1A9E:  GOTO   2A1
....................             else
....................             {
....................                high_temp = high_temp + 1;
1A9F:  MOVLW  01
1AA0:  ADDWF  39,F
....................             }
....................          }
1AA1:  GOTO   351
....................          else if(set_count==2)
1AA2:  MOVF   2F,W
1AA3:  SUBLW  02
1AA4:  BTFSS  03.2
1AA5:  GOTO   2B2
....................          {
....................             if(low_temp >= 125)
1AA6:  BTFSC  3A.7
1AA7:  GOTO   2AF
1AA8:  MOVF   3A,W
1AA9:  SUBLW  7C
1AAA:  BTFSC  03.0
1AAB:  GOTO   2AF
....................             {
....................                low_temp =125;
1AAC:  MOVLW  7D
1AAD:  MOVWF  3A
....................             }
1AAE:  GOTO   2B1
....................             else
....................             {
....................                low_temp = low_temp + 1;
1AAF:  MOVLW  01
1AB0:  ADDWF  3A,F
....................             }
....................          }
1AB1:  GOTO   351
....................          else if(set_count==3)
1AB2:  MOVF   2F,W
1AB3:  SUBLW  03
1AB4:  BTFSS  03.2
1AB5:  GOTO   302
....................          {
....................             if(deadband >= 50)
1AB6:  BSF    03.6
1AB7:  CLRF   39
1AB8:  CLRF   38
1AB9:  MOVLW  48
1ABA:  MOVWF  37
1ABB:  MOVLW  84
1ABC:  MOVWF  36
1ABD:  BCF    03.6
1ABE:  MOVF   38,W
1ABF:  BSF    03.6
1AC0:  MOVWF  3D
1AC1:  BCF    03.6
1AC2:  MOVF   37,W
1AC3:  BSF    03.6
1AC4:  MOVWF  3C
1AC5:  BCF    03.6
1AC6:  MOVF   36,W
1AC7:  BSF    03.6
1AC8:  MOVWF  3B
1AC9:  BCF    03.6
1ACA:  MOVF   35,W
1ACB:  BSF    03.6
1ACC:  MOVWF  3A
1ACD:  BCF    0A.4
1ACE:  BCF    0A.3
1ACF:  BCF    03.6
1AD0:  CALL   695
1AD1:  BSF    0A.4
1AD2:  BSF    0A.3
1AD3:  BTFSC  03.0
1AD4:  GOTO   2D7
1AD5:  BTFSS  03.2
1AD6:  GOTO   2DE
....................             {
....................                deadband =50;
1AD7:  CLRF   38
1AD8:  CLRF   37
1AD9:  MOVLW  48
1ADA:  MOVWF  36
1ADB:  MOVLW  84
1ADC:  MOVWF  35
....................             }
1ADD:  GOTO   301
....................             else
....................             {
....................                deadband = deadband + 1;
1ADE:  BCF    03.1
1ADF:  MOVF   38,W
1AE0:  BSF    03.6
1AE1:  MOVWF  39
1AE2:  BCF    03.6
1AE3:  MOVF   37,W
1AE4:  BSF    03.6
1AE5:  MOVWF  38
1AE6:  BCF    03.6
1AE7:  MOVF   36,W
1AE8:  BSF    03.6
1AE9:  MOVWF  37
1AEA:  BCF    03.6
1AEB:  MOVF   35,W
1AEC:  BSF    03.6
1AED:  MOVWF  36
1AEE:  CLRF   3D
1AEF:  CLRF   3C
1AF0:  CLRF   3B
1AF1:  MOVLW  7F
1AF2:  MOVWF  3A
1AF3:  BCF    0A.4
1AF4:  BCF    0A.3
1AF5:  BCF    03.6
1AF6:  CALL   54F
1AF7:  BSF    0A.4
1AF8:  BSF    0A.3
1AF9:  MOVF   7A,W
1AFA:  MOVWF  38
1AFB:  MOVF   79,W
1AFC:  MOVWF  37
1AFD:  MOVF   78,W
1AFE:  MOVWF  36
1AFF:  MOVF   77,W
1B00:  MOVWF  35
....................             }
....................          }
1B01:  GOTO   351
....................          else if(set_count==4)
1B02:  MOVF   2F,W
1B03:  SUBLW  04
1B04:  BTFSS  03.2
1B05:  GOTO   351
....................          {
....................             if(temp_offset >= 99)
1B06:  BSF    03.6
1B07:  CLRF   39
1B08:  CLRF   38
1B09:  MOVLW  46
1B0A:  MOVWF  37
1B0B:  MOVLW  85
1B0C:  MOVWF  36
1B0D:  BCF    03.6
1B0E:  MOVF   34,W
1B0F:  BSF    03.6
1B10:  MOVWF  3D
1B11:  BCF    03.6
1B12:  MOVF   33,W
1B13:  BSF    03.6
1B14:  MOVWF  3C
1B15:  BCF    03.6
1B16:  MOVF   32,W
1B17:  BSF    03.6
1B18:  MOVWF  3B
1B19:  BCF    03.6
1B1A:  MOVF   31,W
1B1B:  BSF    03.6
1B1C:  MOVWF  3A
1B1D:  BCF    0A.4
1B1E:  BCF    0A.3
1B1F:  BCF    03.6
1B20:  CALL   695
1B21:  BSF    0A.4
1B22:  BSF    0A.3
1B23:  BTFSC  03.0
1B24:  GOTO   327
1B25:  BTFSS  03.2
1B26:  GOTO   32E
....................             {
....................                temp_offset =99;
1B27:  CLRF   34
1B28:  CLRF   33
1B29:  MOVLW  46
1B2A:  MOVWF  32
1B2B:  MOVLW  85
1B2C:  MOVWF  31
....................             }
1B2D:  GOTO   351
....................             else
....................             {
....................                temp_offset = temp_offset + 1;
1B2E:  BCF    03.1
1B2F:  MOVF   34,W
1B30:  BSF    03.6
1B31:  MOVWF  39
1B32:  BCF    03.6
1B33:  MOVF   33,W
1B34:  BSF    03.6
1B35:  MOVWF  38
1B36:  BCF    03.6
1B37:  MOVF   32,W
1B38:  BSF    03.6
1B39:  MOVWF  37
1B3A:  BCF    03.6
1B3B:  MOVF   31,W
1B3C:  BSF    03.6
1B3D:  MOVWF  36
1B3E:  CLRF   3D
1B3F:  CLRF   3C
1B40:  CLRF   3B
1B41:  MOVLW  7F
1B42:  MOVWF  3A
1B43:  BCF    0A.4
1B44:  BCF    0A.3
1B45:  BCF    03.6
1B46:  CALL   54F
1B47:  BSF    0A.4
1B48:  BSF    0A.3
1B49:  MOVF   7A,W
1B4A:  MOVWF  34
1B4B:  MOVF   79,W
1B4C:  MOVWF  33
1B4D:  MOVF   78,W
1B4E:  MOVWF  32
1B4F:  MOVF   77,W
1B50:  MOVWF  31
....................             }
....................          }         
....................       }
....................    }
1B51:  GOTO   41B
....................    //Tru
....................    else if(input(pin_D5)==0)
1B52:  BTFSC  08.5
1B53:  GOTO   41B
....................    {
....................       delay_ms(50);
1B54:  MOVLW  32
1B55:  BSF    03.6
1B56:  MOVWF  3F
1B57:  BCF    0A.4
1B58:  BCF    0A.3
1B59:  BCF    03.6
1B5A:  CALL   791
1B5B:  BSF    0A.4
1B5C:  BSF    0A.3
....................       if(input(pin_D5)==0)
1B5D:  BTFSC  08.5
1B5E:  GOTO   41B
....................       {
....................          delay_ms(50);
1B5F:  MOVLW  32
1B60:  BSF    03.6
1B61:  MOVWF  3F
1B62:  BCF    0A.4
1B63:  BCF    0A.3
1B64:  BCF    03.6
1B65:  CALL   791
1B66:  BSF    0A.4
1B67:  BSF    0A.3
....................          if(set_count==1)
1B68:  DECFSZ 2F,W
1B69:  GOTO   375
....................          {
....................             if(high_temp <= -55)
1B6A:  MOVF   39,W
1B6B:  XORLW  80
1B6C:  SUBLW  49
1B6D:  BTFSS  03.0
1B6E:  GOTO   372
....................             {
....................                high_temp =-55;
1B6F:  MOVLW  C9
1B70:  MOVWF  39
....................             }
1B71:  GOTO   374
....................             else
....................             {
....................                high_temp = high_temp - 1;
1B72:  MOVLW  01
1B73:  SUBWF  39,F
....................             }
....................          }
1B74:  GOTO   41B
....................          else if(set_count==2)
1B75:  MOVF   2F,W
1B76:  SUBLW  02
1B77:  BTFSS  03.2
1B78:  GOTO   384
....................          {
....................             if(low_temp <= -55)
1B79:  MOVF   3A,W
1B7A:  XORLW  80
1B7B:  SUBLW  49
1B7C:  BTFSS  03.0
1B7D:  GOTO   381
....................             {
....................                low_temp =-55;
1B7E:  MOVLW  C9
1B7F:  MOVWF  3A
....................             }
1B80:  GOTO   383
....................             else
....................             {
....................                low_temp = low_temp - 1;
1B81:  MOVLW  01
1B82:  SUBWF  3A,F
....................             }
....................          }
1B83:  GOTO   41B
....................          else if(set_count==3)
1B84:  MOVF   2F,W
1B85:  SUBLW  03
1B86:  BTFSS  03.2
1B87:  GOTO   3CE
....................          {
....................             if(deadband <= 0)
1B88:  MOVF   38,W
1B89:  BSF    03.6
1B8A:  MOVWF  39
1B8B:  BCF    03.6
1B8C:  MOVF   37,W
1B8D:  BSF    03.6
1B8E:  MOVWF  38
1B8F:  BCF    03.6
1B90:  MOVF   36,W
1B91:  BSF    03.6
1B92:  MOVWF  37
1B93:  BCF    03.6
1B94:  MOVF   35,W
1B95:  BSF    03.6
1B96:  MOVWF  36
1B97:  CLRF   3D
1B98:  CLRF   3C
1B99:  CLRF   3B
1B9A:  CLRF   3A
1B9B:  BCF    0A.4
1B9C:  BCF    0A.3
1B9D:  BCF    03.6
1B9E:  CALL   695
1B9F:  BSF    0A.4
1BA0:  BSF    0A.3
1BA1:  BTFSC  03.0
1BA2:  GOTO   3A5
1BA3:  BTFSS  03.2
1BA4:  GOTO   3AA
....................             {
....................                deadband =0;
1BA5:  CLRF   38
1BA6:  CLRF   37
1BA7:  CLRF   36
1BA8:  CLRF   35
....................             }
1BA9:  GOTO   3CD
....................             else
....................             {
....................                deadband = deadband - 1;
1BAA:  BSF    03.1
1BAB:  MOVF   38,W
1BAC:  BSF    03.6
1BAD:  MOVWF  39
1BAE:  BCF    03.6
1BAF:  MOVF   37,W
1BB0:  BSF    03.6
1BB1:  MOVWF  38
1BB2:  BCF    03.6
1BB3:  MOVF   36,W
1BB4:  BSF    03.6
1BB5:  MOVWF  37
1BB6:  BCF    03.6
1BB7:  MOVF   35,W
1BB8:  BSF    03.6
1BB9:  MOVWF  36
1BBA:  CLRF   3D
1BBB:  CLRF   3C
1BBC:  CLRF   3B
1BBD:  MOVLW  7F
1BBE:  MOVWF  3A
1BBF:  BCF    0A.4
1BC0:  BCF    0A.3
1BC1:  BCF    03.6
1BC2:  CALL   54F
1BC3:  BSF    0A.4
1BC4:  BSF    0A.3
1BC5:  MOVF   7A,W
1BC6:  MOVWF  38
1BC7:  MOVF   79,W
1BC8:  MOVWF  37
1BC9:  MOVF   78,W
1BCA:  MOVWF  36
1BCB:  MOVF   77,W
1BCC:  MOVWF  35
....................             }
....................          }
1BCD:  GOTO   41B
....................          else if(set_count==4)
1BCE:  MOVF   2F,W
1BCF:  SUBLW  04
1BD0:  BTFSS  03.2
1BD1:  GOTO   41B
....................          {
....................             if(temp_offset <= -99)
1BD2:  MOVF   34,W
1BD3:  BSF    03.6
1BD4:  MOVWF  39
1BD5:  BCF    03.6
1BD6:  MOVF   33,W
1BD7:  BSF    03.6
1BD8:  MOVWF  38
1BD9:  BCF    03.6
1BDA:  MOVF   32,W
1BDB:  BSF    03.6
1BDC:  MOVWF  37
1BDD:  BCF    03.6
1BDE:  MOVF   31,W
1BDF:  BSF    03.6
1BE0:  MOVWF  36
1BE1:  CLRF   3D
1BE2:  CLRF   3C
1BE3:  MOVLW  C6
1BE4:  MOVWF  3B
1BE5:  MOVLW  85
1BE6:  MOVWF  3A
1BE7:  BCF    0A.4
1BE8:  BCF    0A.3
1BE9:  BCF    03.6
1BEA:  CALL   695
1BEB:  BSF    0A.4
1BEC:  BSF    0A.3
1BED:  BTFSC  03.0
1BEE:  GOTO   3F1
1BEF:  BTFSS  03.2
1BF0:  GOTO   3F8
....................             {
....................                temp_offset =-99;
1BF1:  CLRF   34
1BF2:  CLRF   33
1BF3:  MOVLW  C6
1BF4:  MOVWF  32
1BF5:  MOVLW  85
1BF6:  MOVWF  31
....................             }
1BF7:  GOTO   41B
....................             else
....................             {
....................                temp_offset = temp_offset - 1;
1BF8:  BSF    03.1
1BF9:  MOVF   34,W
1BFA:  BSF    03.6
1BFB:  MOVWF  39
1BFC:  BCF    03.6
1BFD:  MOVF   33,W
1BFE:  BSF    03.6
1BFF:  MOVWF  38
1C00:  BCF    03.6
1C01:  MOVF   32,W
1C02:  BSF    03.6
1C03:  MOVWF  37
1C04:  BCF    03.6
1C05:  MOVF   31,W
1C06:  BSF    03.6
1C07:  MOVWF  36
1C08:  CLRF   3D
1C09:  CLRF   3C
1C0A:  CLRF   3B
1C0B:  MOVLW  7F
1C0C:  MOVWF  3A
1C0D:  BCF    0A.4
1C0E:  BCF    0A.3
1C0F:  BCF    03.6
1C10:  CALL   54F
1C11:  BSF    0A.4
1C12:  BSF    0A.3
1C13:  MOVF   7A,W
1C14:  MOVWF  34
1C15:  MOVF   79,W
1C16:  MOVWF  33
1C17:  MOVF   78,W
1C18:  MOVWF  32
1C19:  MOVF   77,W
1C1A:  MOVWF  31
....................             }
....................          }               
....................       }
....................    }
....................    //SET
....................    if(((input(pin_D7)==0)&&(Old_Mode==0)))
1C1B:  BTFSC  08.7
1C1C:  GOTO   42A
1C1D:  BTFSC  2A.3
1C1E:  GOTO   42A
....................    {
....................       delay_ms(10);
1C1F:  MOVLW  0A
1C20:  BSF    03.6
1C21:  MOVWF  3F
1C22:  BCF    0A.4
1C23:  BCF    0A.3
1C24:  BCF    03.6
1C25:  CALL   791
1C26:  BSF    0A.4
1C27:  BSF    0A.3
....................       Old_Mode=1;
1C28:  BSF    2A.3
....................    }
1C29:  GOTO   479
....................    else if(((input(pin_D7)==1)&&(Old_Mode==1)))
1C2A:  BTFSS  08.7
1C2B:  GOTO   479
1C2C:  BTFSS  2A.3
1C2D:  GOTO   479
....................    {
....................       Old_Mode=0;
1C2E:  BCF    2A.3
....................       set_count++;
1C2F:  INCF   2F,F
....................       //Return to runtime mode
....................       if(set_count > 4)
1C30:  MOVF   2F,W
1C31:  SUBLW  04
1C32:  BTFSC  03.0
1C33:  GOTO   479
....................       {
....................          set_count=1;
1C34:  MOVLW  01
1C35:  MOVWF  2F
....................          alarmACK=0;
1C36:  BCF    2A.5
....................          Config=0;
1C37:  CLRF   30
....................          big_hold_regs[1] = high_temp; 
1C38:  CLRF   7A
1C39:  MOVF   39,W
1C3A:  BTFSC  39.7
1C3B:  DECF   7A,F
1C3C:  MOVWF  4E
1C3D:  MOVF   7A,W
1C3E:  MOVWF  4F
....................          big_hold_regs[2] = low_temp;
1C3F:  CLRF   7A
1C40:  MOVF   3A,W
1C41:  BTFSC  3A.7
1C42:  DECF   7A,F
1C43:  MOVWF  50
1C44:  MOVF   7A,W
1C45:  MOVWF  51
....................          big_hold_regs[3] = deadband; 
1C46:  MOVF   38,W
1C47:  BSF    03.6
1C48:  MOVWF  35
1C49:  BCF    03.6
1C4A:  MOVF   37,W
1C4B:  BSF    03.6
1C4C:  MOVWF  34
1C4D:  BCF    03.6
1C4E:  MOVF   36,W
1C4F:  BSF    03.6
1C50:  MOVWF  33
1C51:  BCF    03.6
1C52:  MOVF   35,W
1C53:  BSF    03.6
1C54:  MOVWF  32
1C55:  BCF    0A.4
1C56:  BCF    0A.3
1C57:  BCF    03.6
1C58:  CALL   6D6
1C59:  BSF    0A.4
1C5A:  BSF    0A.3
1C5B:  MOVF   79,W
1C5C:  MOVWF  53
1C5D:  MOVF   78,W
1C5E:  MOVWF  52
....................          big_hold_regs[4] = Temp_offset; 
1C5F:  MOVF   34,W
1C60:  BSF    03.6
1C61:  MOVWF  35
1C62:  BCF    03.6
1C63:  MOVF   33,W
1C64:  BSF    03.6
1C65:  MOVWF  34
1C66:  BCF    03.6
1C67:  MOVF   32,W
1C68:  BSF    03.6
1C69:  MOVWF  33
1C6A:  BCF    03.6
1C6B:  MOVF   31,W
1C6C:  BSF    03.6
1C6D:  MOVWF  32
1C6E:  BCF    0A.4
1C6F:  BCF    0A.3
1C70:  BCF    03.6
1C71:  CALL   6D6
1C72:  BSF    0A.4
1C73:  BSF    0A.3
1C74:  MOVF   79,W
1C75:  MOVWF  55
1C76:  MOVF   78,W
1C77:  MOVWF  54
....................          Ghi_rom=1;
1C78:  BSF    2A.2
....................       }                  
....................    }
....................    display(temp_array,MAXNUM, control_array);// hien thi ra led 7 doan  
1C79:  BSF    03.6
1C7A:  CLRF   33
1C7B:  MOVLW  41
1C7C:  MOVWF  32
1C7D:  MOVLW  04
1C7E:  MOVWF  34
1C7F:  CLRF   36
1C80:  MOVLW  2B
1C81:  MOVWF  35
1C82:  BCF    0A.4
1C83:  BCF    03.6
1C84:  CALL   5E3
1C85:  BSF    0A.4
1C86:  BSF    0A.3
1C87:  BSF    0A.4
1C88:  GOTO   7A9 (RETURN)
.................... }
.................... Void Ghi_eeprom()
.................... {
....................    // high Alarm
....................    if(high_temp>=0)
*
1419:  BTFSC  39.7
141A:  GOTO   494
....................    {
....................       // Ghi rom
....................       m=(int8)high_temp/100;
141B:  MOVF   39,W
141C:  BSF    03.6
141D:  MOVWF  33
141E:  MOVLW  64
141F:  MOVWF  34
1420:  BCF    0A.4
1421:  BCF    03.6
1422:  CALL   6F7
1423:  BSF    0A.4
1424:  MOVF   78,W
1425:  MOVWF  29
....................       write_eeprom(0,m);
1426:  MOVF   0B,W
1427:  MOVWF  77
1428:  BCF    0B.7
1429:  BSF    03.6
142A:  CLRF   0D
142B:  BCF    03.6
142C:  MOVF   29,W
142D:  BSF    03.6
142E:  MOVWF  0C
142F:  BSF    03.5
1430:  BCF    0C.7
1431:  BSF    0C.2
1432:  MOVLW  55
1433:  MOVWF  0D
1434:  MOVLW  AA
1435:  MOVWF  0D
1436:  BSF    0C.1
1437:  BTFSC  0C.1
1438:  GOTO   437
1439:  BCF    0C.2
143A:  MOVF   77,W
143B:  BCF    03.5
143C:  BCF    03.6
143D:  IORWF  0B,F
....................       m=(int8)(high_temp/10)%10;
143E:  MOVF   39,W
143F:  BSF    03.6
1440:  MOVWF  33
1441:  MOVLW  0A
1442:  MOVWF  34
1443:  BCF    0A.4
1444:  BSF    0A.3
1445:  BCF    03.6
1446:  CALL   7D2
1447:  BSF    0A.4
1448:  BCF    0A.3
1449:  MOVF   78,W
144A:  BSF    03.6
144B:  MOVWF  33
144C:  MOVLW  0A
144D:  MOVWF  34
144E:  BCF    0A.4
144F:  BSF    0A.3
1450:  BCF    03.6
1451:  CALL   7D2
1452:  BSF    0A.4
1453:  BCF    0A.3
1454:  MOVF   77,W
1455:  MOVWF  29
....................       write_eeprom(1,m);
1456:  MOVF   0B,W
1457:  MOVWF  77
1458:  BCF    0B.7
1459:  MOVLW  01
145A:  BSF    03.6
145B:  MOVWF  0D
145C:  BCF    03.6
145D:  MOVF   29,W
145E:  BSF    03.6
145F:  MOVWF  0C
1460:  BSF    03.5
1461:  BCF    0C.7
1462:  BSF    0C.2
1463:  MOVLW  55
1464:  MOVWF  0D
1465:  MOVLW  AA
1466:  MOVWF  0D
1467:  BSF    0C.1
1468:  BTFSC  0C.1
1469:  GOTO   468
146A:  BCF    0C.2
146B:  MOVF   77,W
146C:  BCF    03.5
146D:  BCF    03.6
146E:  IORWF  0B,F
....................       m=(int8)high_temp%10;
146F:  MOVF   39,W
1470:  BSF    03.6
1471:  MOVWF  33
1472:  MOVLW  0A
1473:  MOVWF  34
1474:  BCF    0A.4
1475:  BCF    03.6
1476:  CALL   6F7
1477:  BSF    0A.4
1478:  MOVF   77,W
1479:  MOVWF  29
....................       write_eeprom(2,m);
147A:  MOVF   0B,W
147B:  MOVWF  77
147C:  BCF    0B.7
147D:  MOVLW  02
147E:  BSF    03.6
147F:  MOVWF  0D
1480:  BCF    03.6
1481:  MOVF   29,W
1482:  BSF    03.6
1483:  MOVWF  0C
1484:  BSF    03.5
1485:  BCF    0C.7
1486:  BSF    0C.2
1487:  MOVLW  55
1488:  MOVWF  0D
1489:  MOVLW  AA
148A:  MOVWF  0D
148B:  BSF    0C.1
148C:  BTFSC  0C.1
148D:  GOTO   48C
148E:  BCF    0C.2
148F:  MOVF   77,W
1490:  BCF    03.5
1491:  BCF    03.6
1492:  IORWF  0B,F
....................    }
1493:  GOTO   50C
....................    else
....................    {
....................       // Ghi rom
....................       m=10;
1494:  MOVLW  0A
1495:  MOVWF  29
....................       write_eeprom(0,m);
1496:  MOVF   0B,W
1497:  MOVWF  77
1498:  BCF    0B.7
1499:  BSF    03.6
149A:  CLRF   0D
149B:  BCF    03.6
149C:  MOVF   29,W
149D:  BSF    03.6
149E:  MOVWF  0C
149F:  BSF    03.5
14A0:  BCF    0C.7
14A1:  BSF    0C.2
14A2:  MOVLW  55
14A3:  MOVWF  0D
14A4:  MOVLW  AA
14A5:  MOVWF  0D
14A6:  BSF    0C.1
14A7:  BTFSC  0C.1
14A8:  GOTO   4A7
14A9:  BCF    0C.2
14AA:  MOVF   77,W
14AB:  BCF    03.5
14AC:  BCF    03.6
14AD:  IORWF  0B,F
....................       m=(int8)(high_temp*(-1))/10;
14AE:  MOVF   39,W
14AF:  BSF    03.6
14B0:  MOVWF  33
14B1:  MOVLW  FF
14B2:  MOVWF  34
14B3:  BCF    0A.4
14B4:  BCF    03.6
14B5:  CALL   7C8
14B6:  BSF    0A.4
14B7:  MOVF   78,W
14B8:  BSF    03.6
14B9:  MOVWF  33
14BA:  MOVLW  0A
14BB:  MOVWF  34
14BC:  BCF    0A.4
14BD:  BSF    0A.3
14BE:  BCF    03.6
14BF:  CALL   7D2
14C0:  BSF    0A.4
14C1:  BCF    0A.3
14C2:  MOVF   78,W
14C3:  MOVWF  29
....................       write_eeprom(1,m);
14C4:  MOVF   0B,W
14C5:  MOVWF  77
14C6:  BCF    0B.7
14C7:  MOVLW  01
14C8:  BSF    03.6
14C9:  MOVWF  0D
14CA:  BCF    03.6
14CB:  MOVF   29,W
14CC:  BSF    03.6
14CD:  MOVWF  0C
14CE:  BSF    03.5
14CF:  BCF    0C.7
14D0:  BSF    0C.2
14D1:  MOVLW  55
14D2:  MOVWF  0D
14D3:  MOVLW  AA
14D4:  MOVWF  0D
14D5:  BSF    0C.1
14D6:  BTFSC  0C.1
14D7:  GOTO   4D6
14D8:  BCF    0C.2
14D9:  MOVF   77,W
14DA:  BCF    03.5
14DB:  BCF    03.6
14DC:  IORWF  0B,F
....................       m=(int8)(high_temp*(-1))%10;
14DD:  MOVF   39,W
14DE:  BSF    03.6
14DF:  MOVWF  33
14E0:  MOVLW  FF
14E1:  MOVWF  34
14E2:  BCF    0A.4
14E3:  BCF    03.6
14E4:  CALL   7C8
14E5:  BSF    0A.4
14E6:  MOVF   78,W
14E7:  BSF    03.6
14E8:  MOVWF  33
14E9:  MOVLW  0A
14EA:  MOVWF  34
14EB:  BCF    0A.4
14EC:  BSF    0A.3
14ED:  BCF    03.6
14EE:  CALL   7D2
14EF:  BSF    0A.4
14F0:  BCF    0A.3
14F1:  MOVF   77,W
14F2:  MOVWF  29
....................       write_eeprom(2,m);            
14F3:  MOVF   0B,W
14F4:  MOVWF  77
14F5:  BCF    0B.7
14F6:  MOVLW  02
14F7:  BSF    03.6
14F8:  MOVWF  0D
14F9:  BCF    03.6
14FA:  MOVF   29,W
14FB:  BSF    03.6
14FC:  MOVWF  0C
14FD:  BSF    03.5
14FE:  BCF    0C.7
14FF:  BSF    0C.2
1500:  MOVLW  55
1501:  MOVWF  0D
1502:  MOVLW  AA
1503:  MOVWF  0D
1504:  BSF    0C.1
1505:  BTFSC  0C.1
1506:  GOTO   505
1507:  BCF    0C.2
1508:  MOVF   77,W
1509:  BCF    03.5
150A:  BCF    03.6
150B:  IORWF  0B,F
....................    }
....................    // Low Alarm
....................    if(low_temp>=0)
150C:  BTFSC  3A.7
150D:  GOTO   588
....................    {
....................       // Ghi rom
....................       m=(int8)low_temp/100;
150E:  MOVF   3A,W
150F:  BSF    03.6
1510:  MOVWF  33
1511:  MOVLW  64
1512:  MOVWF  34
1513:  BCF    0A.4
1514:  BCF    03.6
1515:  CALL   6F7
1516:  BSF    0A.4
1517:  MOVF   78,W
1518:  MOVWF  29
....................       write_eeprom(3,m);
1519:  MOVF   0B,W
151A:  MOVWF  77
151B:  BCF    0B.7
151C:  MOVLW  03
151D:  BSF    03.6
151E:  MOVWF  0D
151F:  BCF    03.6
1520:  MOVF   29,W
1521:  BSF    03.6
1522:  MOVWF  0C
1523:  BSF    03.5
1524:  BCF    0C.7
1525:  BSF    0C.2
1526:  MOVLW  55
1527:  MOVWF  0D
1528:  MOVLW  AA
1529:  MOVWF  0D
152A:  BSF    0C.1
152B:  BTFSC  0C.1
152C:  GOTO   52B
152D:  BCF    0C.2
152E:  MOVF   77,W
152F:  BCF    03.5
1530:  BCF    03.6
1531:  IORWF  0B,F
....................       m=(int8)(low_temp/10)%10;
1532:  MOVF   3A,W
1533:  BSF    03.6
1534:  MOVWF  33
1535:  MOVLW  0A
1536:  MOVWF  34
1537:  BCF    0A.4
1538:  BSF    0A.3
1539:  BCF    03.6
153A:  CALL   7D2
153B:  BSF    0A.4
153C:  BCF    0A.3
153D:  MOVF   78,W
153E:  BSF    03.6
153F:  MOVWF  33
1540:  MOVLW  0A
1541:  MOVWF  34
1542:  BCF    0A.4
1543:  BSF    0A.3
1544:  BCF    03.6
1545:  CALL   7D2
1546:  BSF    0A.4
1547:  BCF    0A.3
1548:  MOVF   77,W
1549:  MOVWF  29
....................       write_eeprom(4,m);
154A:  MOVF   0B,W
154B:  MOVWF  77
154C:  BCF    0B.7
154D:  MOVLW  04
154E:  BSF    03.6
154F:  MOVWF  0D
1550:  BCF    03.6
1551:  MOVF   29,W
1552:  BSF    03.6
1553:  MOVWF  0C
1554:  BSF    03.5
1555:  BCF    0C.7
1556:  BSF    0C.2
1557:  MOVLW  55
1558:  MOVWF  0D
1559:  MOVLW  AA
155A:  MOVWF  0D
155B:  BSF    0C.1
155C:  BTFSC  0C.1
155D:  GOTO   55C
155E:  BCF    0C.2
155F:  MOVF   77,W
1560:  BCF    03.5
1561:  BCF    03.6
1562:  IORWF  0B,F
....................       m=(int8)low_temp%10;
1563:  MOVF   3A,W
1564:  BSF    03.6
1565:  MOVWF  33
1566:  MOVLW  0A
1567:  MOVWF  34
1568:  BCF    0A.4
1569:  BCF    03.6
156A:  CALL   6F7
156B:  BSF    0A.4
156C:  MOVF   77,W
156D:  MOVWF  29
....................       write_eeprom(5,m);
156E:  MOVF   0B,W
156F:  MOVWF  77
1570:  BCF    0B.7
1571:  MOVLW  05
1572:  BSF    03.6
1573:  MOVWF  0D
1574:  BCF    03.6
1575:  MOVF   29,W
1576:  BSF    03.6
1577:  MOVWF  0C
1578:  BSF    03.5
1579:  BCF    0C.7
157A:  BSF    0C.2
157B:  MOVLW  55
157C:  MOVWF  0D
157D:  MOVLW  AA
157E:  MOVWF  0D
157F:  BSF    0C.1
1580:  BTFSC  0C.1
1581:  GOTO   580
1582:  BCF    0C.2
1583:  MOVF   77,W
1584:  BCF    03.5
1585:  BCF    03.6
1586:  IORWF  0B,F
....................    }
1587:  GOTO   601
....................    else
....................    {
....................       // Ghi rom
....................       m=10;
1588:  MOVLW  0A
1589:  MOVWF  29
....................       write_eeprom(3,m);
158A:  MOVF   0B,W
158B:  MOVWF  77
158C:  BCF    0B.7
158D:  MOVLW  03
158E:  BSF    03.6
158F:  MOVWF  0D
1590:  BCF    03.6
1591:  MOVF   29,W
1592:  BSF    03.6
1593:  MOVWF  0C
1594:  BSF    03.5
1595:  BCF    0C.7
1596:  BSF    0C.2
1597:  MOVLW  55
1598:  MOVWF  0D
1599:  MOVLW  AA
159A:  MOVWF  0D
159B:  BSF    0C.1
159C:  BTFSC  0C.1
159D:  GOTO   59C
159E:  BCF    0C.2
159F:  MOVF   77,W
15A0:  BCF    03.5
15A1:  BCF    03.6
15A2:  IORWF  0B,F
....................       m=(int8)(low_temp*(-1))/10;
15A3:  MOVF   3A,W
15A4:  BSF    03.6
15A5:  MOVWF  33
15A6:  MOVLW  FF
15A7:  MOVWF  34
15A8:  BCF    0A.4
15A9:  BCF    03.6
15AA:  CALL   7C8
15AB:  BSF    0A.4
15AC:  MOVF   78,W
15AD:  BSF    03.6
15AE:  MOVWF  33
15AF:  MOVLW  0A
15B0:  MOVWF  34
15B1:  BCF    0A.4
15B2:  BSF    0A.3
15B3:  BCF    03.6
15B4:  CALL   7D2
15B5:  BSF    0A.4
15B6:  BCF    0A.3
15B7:  MOVF   78,W
15B8:  MOVWF  29
....................       write_eeprom(4,m);
15B9:  MOVF   0B,W
15BA:  MOVWF  77
15BB:  BCF    0B.7
15BC:  MOVLW  04
15BD:  BSF    03.6
15BE:  MOVWF  0D
15BF:  BCF    03.6
15C0:  MOVF   29,W
15C1:  BSF    03.6
15C2:  MOVWF  0C
15C3:  BSF    03.5
15C4:  BCF    0C.7
15C5:  BSF    0C.2
15C6:  MOVLW  55
15C7:  MOVWF  0D
15C8:  MOVLW  AA
15C9:  MOVWF  0D
15CA:  BSF    0C.1
15CB:  BTFSC  0C.1
15CC:  GOTO   5CB
15CD:  BCF    0C.2
15CE:  MOVF   77,W
15CF:  BCF    03.5
15D0:  BCF    03.6
15D1:  IORWF  0B,F
....................       m=(int8)(low_temp*(-1))%10;
15D2:  MOVF   3A,W
15D3:  BSF    03.6
15D4:  MOVWF  33
15D5:  MOVLW  FF
15D6:  MOVWF  34
15D7:  BCF    0A.4
15D8:  BCF    03.6
15D9:  CALL   7C8
15DA:  BSF    0A.4
15DB:  MOVF   78,W
15DC:  BSF    03.6
15DD:  MOVWF  33
15DE:  MOVLW  0A
15DF:  MOVWF  34
15E0:  BCF    0A.4
15E1:  BSF    0A.3
15E2:  BCF    03.6
15E3:  CALL   7D2
15E4:  BSF    0A.4
15E5:  BCF    0A.3
15E6:  MOVF   77,W
15E7:  MOVWF  29
....................       write_eeprom(5,m);            
15E8:  MOVF   0B,W
15E9:  MOVWF  77
15EA:  BCF    0B.7
15EB:  MOVLW  05
15EC:  BSF    03.6
15ED:  MOVWF  0D
15EE:  BCF    03.6
15EF:  MOVF   29,W
15F0:  BSF    03.6
15F1:  MOVWF  0C
15F2:  BSF    03.5
15F3:  BCF    0C.7
15F4:  BSF    0C.2
15F5:  MOVLW  55
15F6:  MOVWF  0D
15F7:  MOVLW  AA
15F8:  MOVWF  0D
15F9:  BSF    0C.1
15FA:  BTFSC  0C.1
15FB:  GOTO   5FA
15FC:  BCF    0C.2
15FD:  MOVF   77,W
15FE:  BCF    03.5
15FF:  BCF    03.6
1600:  IORWF  0B,F
....................    } 
....................    // Deadband
....................    write_eeprom(6,(int8)Deadband); 
1601:  MOVF   38,W
1602:  BSF    03.6
1603:  MOVWF  35
1604:  BCF    03.6
1605:  MOVF   37,W
1606:  BSF    03.6
1607:  MOVWF  34
1608:  BCF    03.6
1609:  MOVF   36,W
160A:  BSF    03.6
160B:  MOVWF  33
160C:  BCF    03.6
160D:  MOVF   35,W
160E:  BSF    03.6
160F:  MOVWF  32
1610:  BCF    0A.4
1611:  BCF    03.6
1612:  CALL   6D6
1613:  BSF    0A.4
1614:  MOVF   78,W
1615:  BSF    03.6
1616:  MOVWF  32
1617:  BCF    03.6
1618:  MOVF   0B,W
1619:  MOVWF  77
161A:  BCF    0B.7
161B:  MOVLW  06
161C:  BSF    03.6
161D:  MOVWF  0D
161E:  MOVF   32,W
161F:  MOVWF  0C
1620:  BSF    03.5
1621:  BCF    0C.7
1622:  BSF    0C.2
1623:  MOVLW  55
1624:  MOVWF  0D
1625:  MOVLW  AA
1626:  MOVWF  0D
1627:  BSF    0C.1
1628:  BTFSC  0C.1
1629:  GOTO   628
162A:  BCF    0C.2
162B:  MOVF   77,W
162C:  BCF    03.5
162D:  BCF    03.6
162E:  IORWF  0B,F
....................     // Offset
....................    if(Temp_offset>=0)
162F:  BSF    03.6
1630:  CLRF   39
1631:  CLRF   38
1632:  CLRF   37
1633:  CLRF   36
1634:  BCF    03.6
1635:  MOVF   34,W
1636:  BSF    03.6
1637:  MOVWF  3D
1638:  BCF    03.6
1639:  MOVF   33,W
163A:  BSF    03.6
163B:  MOVWF  3C
163C:  BCF    03.6
163D:  MOVF   32,W
163E:  BSF    03.6
163F:  MOVWF  3B
1640:  BCF    03.6
1641:  MOVF   31,W
1642:  BSF    03.6
1643:  MOVWF  3A
1644:  BCF    0A.4
1645:  BCF    03.6
1646:  CALL   695
1647:  BSF    0A.4
1648:  BTFSC  03.0
1649:  GOTO   64C
164A:  BTFSS  03.2
164B:  GOTO   6D5
....................    {
....................       // Ghi rom
....................       m=0;
164C:  CLRF   29
....................       write_eeprom(7,m);
164D:  MOVF   0B,W
164E:  MOVWF  77
164F:  BCF    0B.7
1650:  MOVLW  07
1651:  BSF    03.6
1652:  MOVWF  0D
1653:  BCF    03.6
1654:  MOVF   29,W
1655:  BSF    03.6
1656:  MOVWF  0C
1657:  BSF    03.5
1658:  BCF    0C.7
1659:  BSF    0C.2
165A:  MOVLW  55
165B:  MOVWF  0D
165C:  MOVLW  AA
165D:  MOVWF  0D
165E:  BSF    0C.1
165F:  BTFSC  0C.1
1660:  GOTO   65F
1661:  BCF    0C.2
1662:  MOVF   77,W
1663:  BCF    03.5
1664:  BCF    03.6
1665:  IORWF  0B,F
....................       m=(int8)Temp_offset/10;
1666:  MOVF   34,W
1667:  BSF    03.6
1668:  MOVWF  35
1669:  BCF    03.6
166A:  MOVF   33,W
166B:  BSF    03.6
166C:  MOVWF  34
166D:  BCF    03.6
166E:  MOVF   32,W
166F:  BSF    03.6
1670:  MOVWF  33
1671:  BCF    03.6
1672:  MOVF   31,W
1673:  BSF    03.6
1674:  MOVWF  32
1675:  BCF    0A.4
1676:  BCF    03.6
1677:  CALL   6D6
1678:  BSF    0A.4
1679:  MOVF   78,W
167A:  BSF    03.6
167B:  MOVWF  33
167C:  MOVLW  0A
167D:  MOVWF  34
167E:  BCF    0A.4
167F:  BCF    03.6
1680:  CALL   6F7
1681:  BSF    0A.4
1682:  MOVF   78,W
1683:  MOVWF  29
....................       write_eeprom(8,m);
1684:  MOVF   0B,W
1685:  MOVWF  77
1686:  BCF    0B.7
1687:  MOVLW  08
1688:  BSF    03.6
1689:  MOVWF  0D
168A:  BCF    03.6
168B:  MOVF   29,W
168C:  BSF    03.6
168D:  MOVWF  0C
168E:  BSF    03.5
168F:  BCF    0C.7
1690:  BSF    0C.2
1691:  MOVLW  55
1692:  MOVWF  0D
1693:  MOVLW  AA
1694:  MOVWF  0D
1695:  BSF    0C.1
1696:  BTFSC  0C.1
1697:  GOTO   696
1698:  BCF    0C.2
1699:  MOVF   77,W
169A:  BCF    03.5
169B:  BCF    03.6
169C:  IORWF  0B,F
....................       m=(int8)Temp_offset%10;
169D:  MOVF   34,W
169E:  BSF    03.6
169F:  MOVWF  35
16A0:  BCF    03.6
16A1:  MOVF   33,W
16A2:  BSF    03.6
16A3:  MOVWF  34
16A4:  BCF    03.6
16A5:  MOVF   32,W
16A6:  BSF    03.6
16A7:  MOVWF  33
16A8:  BCF    03.6
16A9:  MOVF   31,W
16AA:  BSF    03.6
16AB:  MOVWF  32
16AC:  BCF    0A.4
16AD:  BCF    03.6
16AE:  CALL   6D6
16AF:  BSF    0A.4
16B0:  MOVF   78,W
16B1:  BSF    03.6
16B2:  MOVWF  33
16B3:  MOVLW  0A
16B4:  MOVWF  34
16B5:  BCF    0A.4
16B6:  BCF    03.6
16B7:  CALL   6F7
16B8:  BSF    0A.4
16B9:  MOVF   77,W
16BA:  MOVWF  29
....................       write_eeprom(9,m);            
16BB:  MOVF   0B,W
16BC:  MOVWF  77
16BD:  BCF    0B.7
16BE:  MOVLW  09
16BF:  BSF    03.6
16C0:  MOVWF  0D
16C1:  BCF    03.6
16C2:  MOVF   29,W
16C3:  BSF    03.6
16C4:  MOVWF  0C
16C5:  BSF    03.5
16C6:  BCF    0C.7
16C7:  BSF    0C.2
16C8:  MOVLW  55
16C9:  MOVWF  0D
16CA:  MOVLW  AA
16CB:  MOVWF  0D
16CC:  BSF    0C.1
16CD:  BTFSC  0C.1
16CE:  GOTO   6CD
16CF:  BCF    0C.2
16D0:  MOVF   77,W
16D1:  BCF    03.5
16D2:  BCF    03.6
16D3:  IORWF  0B,F
....................    }
16D4:  GOTO   784
....................    else
....................    {
....................       // Ghi rom
....................       m=10;
16D5:  MOVLW  0A
16D6:  MOVWF  29
....................       write_eeprom(7,m);
16D7:  MOVF   0B,W
16D8:  MOVWF  77
16D9:  BCF    0B.7
16DA:  MOVLW  07
16DB:  BSF    03.6
16DC:  MOVWF  0D
16DD:  BCF    03.6
16DE:  MOVF   29,W
16DF:  BSF    03.6
16E0:  MOVWF  0C
16E1:  BSF    03.5
16E2:  BCF    0C.7
16E3:  BSF    0C.2
16E4:  MOVLW  55
16E5:  MOVWF  0D
16E6:  MOVLW  AA
16E7:  MOVWF  0D
16E8:  BSF    0C.1
16E9:  BTFSC  0C.1
16EA:  GOTO   6E9
16EB:  BCF    0C.2
16EC:  MOVF   77,W
16ED:  BCF    03.5
16EE:  BCF    03.6
16EF:  IORWF  0B,F
....................       m=(int8)(Temp_offset*(-1))/10;
16F0:  MOVF   34,W
16F1:  BSF    03.6
16F2:  MOVWF  35
16F3:  BCF    03.6
16F4:  MOVF   33,W
16F5:  BSF    03.6
16F6:  MOVWF  34
16F7:  BCF    03.6
16F8:  MOVF   32,W
16F9:  BSF    03.6
16FA:  MOVWF  33
16FB:  BCF    03.6
16FC:  MOVF   31,W
16FD:  BSF    03.6
16FE:  MOVWF  32
16FF:  CLRF   39
1700:  CLRF   38
1701:  MOVLW  80
1702:  MOVWF  37
1703:  MOVLW  7F
1704:  MOVWF  36
1705:  BCF    0A.4
1706:  BCF    03.6
1707:  CALL   4D8
1708:  BSF    0A.4
1709:  MOVF   7A,W
170A:  BSF    03.6
170B:  MOVWF  35
170C:  MOVF   79,W
170D:  MOVWF  34
170E:  MOVF   78,W
170F:  MOVWF  33
1710:  MOVF   77,W
1711:  MOVWF  32
1712:  BCF    0A.4
1713:  BCF    03.6
1714:  CALL   6D6
1715:  BSF    0A.4
1716:  MOVF   78,W
1717:  BSF    03.6
1718:  MOVWF  33
1719:  MOVLW  0A
171A:  MOVWF  34
171B:  BCF    0A.4
171C:  BCF    03.6
171D:  CALL   6F7
171E:  BSF    0A.4
171F:  MOVF   78,W
1720:  MOVWF  29
....................       write_eeprom(8,m);
1721:  MOVF   0B,W
1722:  MOVWF  77
1723:  BCF    0B.7
1724:  MOVLW  08
1725:  BSF    03.6
1726:  MOVWF  0D
1727:  BCF    03.6
1728:  MOVF   29,W
1729:  BSF    03.6
172A:  MOVWF  0C
172B:  BSF    03.5
172C:  BCF    0C.7
172D:  BSF    0C.2
172E:  MOVLW  55
172F:  MOVWF  0D
1730:  MOVLW  AA
1731:  MOVWF  0D
1732:  BSF    0C.1
1733:  BTFSC  0C.1
1734:  GOTO   733
1735:  BCF    0C.2
1736:  MOVF   77,W
1737:  BCF    03.5
1738:  BCF    03.6
1739:  IORWF  0B,F
....................       m=(int8)(Temp_offset*(-1))%10;
173A:  MOVF   34,W
173B:  BSF    03.6
173C:  MOVWF  35
173D:  BCF    03.6
173E:  MOVF   33,W
173F:  BSF    03.6
1740:  MOVWF  34
1741:  BCF    03.6
1742:  MOVF   32,W
1743:  BSF    03.6
1744:  MOVWF  33
1745:  BCF    03.6
1746:  MOVF   31,W
1747:  BSF    03.6
1748:  MOVWF  32
1749:  CLRF   39
174A:  CLRF   38
174B:  MOVLW  80
174C:  MOVWF  37
174D:  MOVLW  7F
174E:  MOVWF  36
174F:  BCF    0A.4
1750:  BCF    03.6
1751:  CALL   4D8
1752:  BSF    0A.4
1753:  MOVF   7A,W
1754:  BSF    03.6
1755:  MOVWF  35
1756:  MOVF   79,W
1757:  MOVWF  34
1758:  MOVF   78,W
1759:  MOVWF  33
175A:  MOVF   77,W
175B:  MOVWF  32
175C:  BCF    0A.4
175D:  BCF    03.6
175E:  CALL   6D6
175F:  BSF    0A.4
1760:  MOVF   78,W
1761:  BSF    03.6
1762:  MOVWF  33
1763:  MOVLW  0A
1764:  MOVWF  34
1765:  BCF    0A.4
1766:  BCF    03.6
1767:  CALL   6F7
1768:  BSF    0A.4
1769:  MOVF   77,W
176A:  MOVWF  29
....................       write_eeprom(9,m);            
176B:  MOVF   0B,W
176C:  MOVWF  77
176D:  BCF    0B.7
176E:  MOVLW  09
176F:  BSF    03.6
1770:  MOVWF  0D
1771:  BCF    03.6
1772:  MOVF   29,W
1773:  BSF    03.6
1774:  MOVWF  0C
1775:  BSF    03.5
1776:  BCF    0C.7
1777:  BSF    0C.2
1778:  MOVLW  55
1779:  MOVWF  0D
177A:  MOVLW  AA
177B:  MOVWF  0D
177C:  BSF    0C.1
177D:  BTFSC  0C.1
177E:  GOTO   77D
177F:  BCF    0C.2
1780:  MOVF   77,W
1781:  BCF    03.5
1782:  BCF    03.6
1783:  IORWF  0B,F
....................    }
1784:  BSF    0A.3
1785:  BSF    0A.4
1786:  GOTO   7A3 (RETURN)
....................    // Relay Out
....................    //write_eeprom(10,Relay_out);      
.................... }
.................... void Apply_Changes()
.................... {
....................    if(big_hold_regs[6]==100)
*
0F24:  MOVF   58,W
0F25:  SUBLW  64
0F26:  BTFSS  03.2
0F27:  GOTO   7B2
0F28:  MOVF   59,F
0F29:  BTFSS  03.2
0F2A:  GOTO   7B2
....................    {
....................       // High Temp Alarm
....................       if(big_hold_regs[1]>125)
0F2B:  BTFSC  4F.7
0F2C:  GOTO   738
0F2D:  MOVF   4F,F
0F2E:  BTFSS  03.2
0F2F:  GOTO   734
0F30:  MOVF   4E,W
0F31:  SUBLW  7D
0F32:  BTFSC  03.0
0F33:  GOTO   738
....................       {
....................          big_hold_regs[1]=125;
0F34:  CLRF   4F
0F35:  MOVLW  7D
0F36:  MOVWF  4E
....................       }
0F37:  GOTO   748
....................       else if(big_hold_regs[1]<(-55))
0F38:  BTFSS  4F.7
0F39:  GOTO   748
0F3A:  MOVF   4F,W
0F3B:  SUBLW  FF
0F3C:  BTFSS  03.0
0F3D:  GOTO   748
0F3E:  BTFSS  03.2
0F3F:  GOTO   744
0F40:  MOVF   4E,W
0F41:  SUBLW  C8
0F42:  BTFSS  03.0
0F43:  GOTO   748
....................       {
....................          big_hold_regs[1]=-55;
0F44:  MOVLW  FF
0F45:  MOVWF  4F
0F46:  MOVLW  C9
0F47:  MOVWF  4E
....................       }
....................       high_temp = big_hold_regs[1];         
0F48:  MOVF   4E,W
0F49:  MOVWF  39
....................       // Low Temp Alarm    
....................       if(big_hold_regs[2]>125)
0F4A:  BTFSC  51.7
0F4B:  GOTO   757
0F4C:  MOVF   51,F
0F4D:  BTFSS  03.2
0F4E:  GOTO   753
0F4F:  MOVF   50,W
0F50:  SUBLW  7D
0F51:  BTFSC  03.0
0F52:  GOTO   757
....................       {
....................          big_hold_regs[2]=125;
0F53:  CLRF   51
0F54:  MOVLW  7D
0F55:  MOVWF  50
....................       }
0F56:  GOTO   767
....................       else if(big_hold_regs[2]<(-55))
0F57:  BTFSS  51.7
0F58:  GOTO   767
0F59:  MOVF   51,W
0F5A:  SUBLW  FF
0F5B:  BTFSS  03.0
0F5C:  GOTO   767
0F5D:  BTFSS  03.2
0F5E:  GOTO   763
0F5F:  MOVF   50,W
0F60:  SUBLW  C8
0F61:  BTFSS  03.0
0F62:  GOTO   767
....................       {
....................          big_hold_regs[2]=-55;
0F63:  MOVLW  FF
0F64:  MOVWF  51
0F65:  MOVLW  C9
0F66:  MOVWF  50
....................       }
....................       low_temp = big_hold_regs[2];      
0F67:  MOVF   50,W
0F68:  MOVWF  3A
....................       // Deadband     
....................       if(big_hold_regs[3]>50)
0F69:  BTFSC  53.7
0F6A:  GOTO   775
0F6B:  MOVF   53,F
0F6C:  BTFSS  03.2
0F6D:  GOTO   772
0F6E:  MOVF   52,W
0F6F:  SUBLW  32
0F70:  BTFSC  03.0
0F71:  GOTO   775
....................          big_hold_regs[3]=50;
0F72:  CLRF   53
0F73:  MOVLW  32
0F74:  MOVWF  52
....................       Deadband = big_hold_regs[3];
0F75:  MOVF   53,W
0F76:  BSF    03.6
0F77:  MOVWF  37
0F78:  BCF    03.6
0F79:  MOVF   52,W
0F7A:  BSF    03.6
0F7B:  MOVWF  36
0F7C:  BCF    03.6
0F7D:  CALL   6FD
0F7E:  MOVF   7A,W
0F7F:  MOVWF  38
0F80:  MOVF   79,W
0F81:  MOVWF  37
0F82:  MOVF   78,W
0F83:  MOVWF  36
0F84:  MOVF   77,W
0F85:  MOVWF  35
....................       // Temp Calib
....................       if((big_hold_regs[4]>99)||(big_hold_regs[4]<(-99)))
0F86:  BTFSC  55.7
0F87:  GOTO   78F
0F88:  MOVF   55,F
0F89:  BTFSS  03.2
0F8A:  GOTO   79B
0F8B:  MOVF   54,W
0F8C:  SUBLW  63
0F8D:  BTFSS  03.0
0F8E:  GOTO   79B
0F8F:  BTFSS  55.7
0F90:  GOTO   79D
0F91:  MOVF   55,W
0F92:  SUBLW  FF
0F93:  BTFSS  03.0
0F94:  GOTO   79D
0F95:  BTFSS  03.2
0F96:  GOTO   79B
0F97:  MOVF   54,W
0F98:  SUBLW  9C
0F99:  BTFSS  03.0
0F9A:  GOTO   79D
....................          big_hold_regs[4]=0;
0F9B:  CLRF   55
0F9C:  CLRF   54
....................       Temp_offset=(float)big_hold_regs[4];                  
0F9D:  MOVF   55,W
0F9E:  BSF    03.6
0F9F:  MOVWF  37
0FA0:  BCF    03.6
0FA1:  MOVF   54,W
0FA2:  BSF    03.6
0FA3:  MOVWF  36
0FA4:  BCF    03.6
0FA5:  CALL   6FD
0FA6:  MOVF   7A,W
0FA7:  MOVWF  34
0FA8:  MOVF   79,W
0FA9:  MOVWF  33
0FAA:  MOVF   78,W
0FAB:  MOVWF  32
0FAC:  MOVF   77,W
0FAD:  MOVWF  31
....................       
....................       Ghi_Rom=1;
0FAE:  BSF    2A.2
....................       big_hold_regs[6]=0;
0FAF:  CLRF   59
0FB0:  CLRF   58
....................    }
0FB1:  GOTO   7B4
....................    else
....................    {
....................       big_hold_regs[6]=0;
0FB2:  CLRF   59
0FB3:  CLRF   58
....................    }
0FB4:  BSF    0A.3
0FB5:  BSF    0A.4
0FB6:  GOTO   768 (RETURN)
.................... }

Configuration Fuses:
   Word  1: 2CBA   HS WDT NOPUT MCLR PROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
